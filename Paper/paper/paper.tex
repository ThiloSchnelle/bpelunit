% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.3 for LaTeX2e
%
\documentclass{llncs}
\usepackage[latin1]{inputenc}
%
\usepackage{makeidx}  % allows for indexgeneration
%
\begin{document}
%
%\frontmatter          % for the preliminaries
%
\pagestyle{headings}  % switches on printing of running heads
%\addtocmark{Hamiltonian Mechanics} % additional mark in the TOC
%
%\chapter*{Preface}
%
%\vspace{1cm}
%\begin{flushright}\noindent
%\end{flushright}
%
%\chapter*{Organization}
%
%
%\tableofcontents
%
%\mainmatter              % start of the contributions
%
\title{Hamiltonian Mechanics unter besonderer Ber\"ucksichtigung der
h\"ohreren Lehranstalten}
%
\titlerunning{Hamiltonian Mechanics}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{Daniel Lübke \and Alex Salnikow}
%
%\authorrunning{Ivar Ekeland et al.}   % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
%
\institute{Leibniz Universität Hannover, 
FG Software Engineering\\ Welfengarten 1, D-30167 Hannover\\
\email{daniel.luebke@inf.uni-hannover.de},\\
\email{alex.salnikow@se.uni-hannover.de}\\}

\maketitle              % typeset the title of the contribution

\begin{abstract}
BPEL Processes are used to link Web services into service compositions. These compositions reflect business processes which are important to the enterprise. Consequently, the correctness and robustness of the BPEL processes is very important. Testing BPEL processes is therefore mandatory. However, there is no practical metric yet which can be used to evaluate neither the test quality nor the test progress. This paper defines the classical testing metrics like statement coverage and branch coverage for BPEL processes. Additionally, BPEL specific test coverage metrics are introduced which address important properties of the BPEL language. Afterwards, the BPELUnit test framework is extended to support the collection of these metrics in a practical manner. Thereby, testers can better judge the progress and quality of their work.
\end{abstract}
%
\section{Introduction}
[DL] [3/4 page] [paper max 12 pages]

\section{BPEL Testing Foundations} [DL] [1 page]
[1, 2]
\section{Related Work}
\section{Test Coverage Metrics}
Bei der Analyse der Testabdeckung geht es darum festzustellen, wie gut die Codebereiche durch die Tests abgedeckt sind bzw. welche Bereiche gar nicht oder nicht ausreichend abgedeckt sind. Als Grundlage für die zugehörigen Metriken dient die Kontrollstruktur des Prozesses mit ihren Strukturmerkmalen: Zweigen und Anweisungen.
Bei der Definition von Metriken wird darauf geachtet, dass 100% Abdeckung erreichbar ist.
\subsection{BPEL Formalisation}
\begin{definition}[WS-BPEL Process Model] A WS-BPEL Process Model is a tuple $\mathcal{W=(A,\ E,\ C,\ L,\ HR,\ }type_{\mathcal{A}},\ type_{\mathcal{E}},\ instance,\ name,\ <_{seq},\ <_{if},\ serialscp,\\ 
\ process,\ trigger,\ scp_c,\ trigger_c,\ scp_t,\ trigger_{tf},\ \mathcal{LR},\ joincon,\  supjoinf,\\
\ trigger_{jf})$ where: 
\begin{itemize}
	\item $\mathcal{A}$ is a set of activities,
	\item $\mathcal{E}$ is a set of events,
	\item $\mathcal{C}$ is a set of conditions,
	\item $\mathcal{L}$ is a set of control links,
	\item let $\mathcal{B=E\cup C} \cup\{\bot\} $ be a set of labels where $\bot$ denotes the empty label, then $\mathcal{HR\subseteq A\times B\times A}$ is a labeled tree which defines the relation between an activity and its direct sub-activities,
	\item $\forall a\in \mathcal{A},\ let \mathcal{HR}_{p}=_{\pi 1,3}\mathcal{HR}$(the projection of $\mathcal{HR}$ on two activity sets), $children(a)=\{a'\in \mathcal{A}|\mathcal{HR}_p(a,a')\}$ is the set of immediate descendants of a, $descendants(a)=\{a'\in \mathcal{A}|\mathcal{HR}^{+}_{p}(a,a')\}$ is the set of all descendants of a, and $clan(a)=\{a\cup \}$ descendants(a) is the set constituting of a  and all its descendants,
	\item $type_\mathcal{A}:\mathcal{A\rightarrow T_A}$ is a function that assigns types to activities taken from the set of activity types 
	
\begin{itemize}
	\item $\mathcal{T_A=T_B\cup T_S}$
	\item $\mathcal{T_B}=\{receive,\ reply,\ wait,\ assign,\ validate,\ empty,\ 
throw,\ rethrow,\\
\ compensate,\ compensateScope,\ exit\}$
\item $\mathcal{T_S}=\{sequence,\ flow,\ pick,\ if,\ while,\ repeatUntil,\ forEach,\ scope\}$
\end{itemize}
\item $\forall t\in \mathcal{T_A},\mathcal{A}_t=\{a\in \mathcal{A}|type_\mathcal{A}(a)=t\}$ is a set of all activities of type $t$,
\item $type_\mathcal{E}:\mathcal{E\rightarrow T_E}$ is a function that assigns types to events taken from the set of event types $\mathcal{T_E}=\{message,\ alarm,\ fault,\ compensation,\ termination\}.$
\item $\forall t\in \mathcal{T_E},\mathcal{E}_t=\{e\in \mathcal{E}|type_\mathcal{E}(e)=t\}$ is a set of all events of type t,
\item $instance:\mathcal{A}_{receive}\cup \mathcal{A}_{pick}\rightarrow \mathcal{B}$ is a function which sddigns a boolean value to the createInstance attribete of a receive or a pick activity.
\item $let \mathcal{A}^{structured}=\mathcal{A}_{sequense}\cup \mathcal{A}_{flow}\cup \mathcal{A}_{if}\cup \mathcal{A}_{while}\cup \mathcal{A}_{repeatUntil}\cup \mathcal{A}_{forEach}\cup \mathcal{A}_{pick}\cup \mathcal{A}_{scope}$ be a set of structured sctivities, $\forall_{s\in \mathcal{A}^{structured}}(children(s)\neq \emptyset)$, i.e., they are the internal nodes of the HR tree,
\item let $\mathcal{A}^{basic}=\mathcal{A}_{invoke}\cup \mathcal{A}_{receive}\cup \mathcal{A}_{reply}\cup \mathcal{A}_{wait}\cup \mathcal{A}_{assign}\cup \mathcal{A}_{validate}\cup \mathcal{A}_{empty}\cup \mathcal{A}_{validate}\cup \mathcal{A}_{throw}\cup \mathcal{A}_{rethrow}\cup \mathcal{A}_{compensate}\cup \mathcal{A}_{compensateScope}$ be a set of basic activities, $\forall_{s\in \mathcal{A}^{basic}}(children(s)= \emptyset)$, i.e., they are the leaves of the $\mathcal{HR}$ tree,
\item $given A'=A_{sequence}\cup A_{flow},H \cap (A'\times \{\bot\}\times A),$
\item $\forall s\in A-{sequence},\exists an order <^s_{seq} which is strict total order over children(s),$
\item $HR\cap (A_{pick}\times B\times A)=HR\cap (A_{pick}\times E^{normal}\times A), where E^{normal}=E_{message}\cup E_{alarm} provides a set of normal rvents,$
\item $\forall s\in A_{pick},\left|HR\cap (\{s\}\times A'\times B\times A)\right|\geq 1, i.e., a pick activity has at least one message event,$
\item $given A'=A_{switch}\cup A_{while}, HR\cap (A'\times B\times A=HR\cap (A'\times C\times A),) $
\item $\forall s\in A{if}, \exists an order <^{s}_{if} which is a strict total order over children(s),$
\item $\forall s\in A_{if}, let last(s)\in children(s) be  the sub-activity in the last branch evaluated in s such that \neg \exists_{a\in children(s)}(last(s)<^{s}_{if}a), let c\in C, HR(s,c,last(s))\Rightarrow \forall_{assign(c)\in Assign(C)}eval(c,assign(c))=true. Note that last(s) represent the else branch in if activity, which wnsures that at least one of the branches is taken in the activity,$
\item $\forall s\in A_{while},\left| HR\cap (\{s\}\times C\times A)\right|=1, i.e., each while activity has exactly ine sub-activity,$
\item $HR\cap (A_{scope}\times B\times A)=HR\cap (A_{scope} \times (E\times\{\bot \})\times A), where: \forall s \in A_{scope},$
\begin{itemize}
	\item $\left|HR\cap (\{s\}\times \{\bot\}\times A))\right|=1, i.e., each scope has one primary (or main) activity, and therefore A^{mainset}(s)=\{a\in A |\exists_{x \in A}(HR(s,\bot ,x)\wedge a \in clan(x))\} is the set constituting of the main axtivity x of scope s and all descendants of x,$
	\item $\left|HR\cap (\{s\}\times \{E_{fault}\}\times A))\right|\geq 1, i.e., each scope provides at least one fault handler,$
		\item $\left|HR\cap (\{s\}\times \{E_{compensation}\}\times A))\right|\\leq 1, i.e., each scope provides at most one compensation handler,$
\item $\forall t \in T_E,A^{t}_{H}(s)=\{a\in A|\exists_{(e,x)\in E_t \times A}(HR(s,e,x)\wedge a\in clan(x))\} is the set constituting of the top lever activities (represented by x) used for handling all events pf type t for scope s and all descendants of these activities,$
\item $A^{event}_{H}(s)=A^{message}_{H}(s)\cup A^{alarm}_{H}(s) is the set of activities used by all events handlers of scope s, and therefor A^{normal}(s)=A^{mainset}(s)\cup A^{event}_{H}(s) is the set of all acrivities that define the normal behaviour of scope s, $
\item $A^{directenc}(s)=descendants(s)\\(\bigcup_{x\in A_{scope}\cap children(s)}descendants(x)) is the set of all activities that are directly enclosed in scope s,$
\end{itemize}
\item $process\in A_{scope} is the root of the HR tree,$
\item $trigger_{tf}:A_{throw}\cup A_{rethrow}\rightarrow E_{fault} is a function which maps each throw activity to a (process-defined) fault event triggered by that activity,$
\item $scp_c:E_{compensation}\rightarrow A_{scope}\\\{process\} is an injective function mapping a compensation event to a (non-process) scope such that the occurrence of that event invokes the compensation of that scope,$
\item $trigger_c:A_{compensate}\rightarrow E_{compensation} is an injective function which maps each compensate activity
to a compensation event triggered by that activity,$
\item $\forall s\in A_{scope}, A_{compensate}\cup (A^{normal}(s)\cap A^{directenc}(s))=\emptyset, i.e., a compensate activity cannot be
used for the normal behaviour of a scope, that is, it may be used only for exception handling and
termination,$
\item $\forall s\in A_{scope}, let A^{fct}_H(s)=A^{fault}_H(s)\cup A^{compensation}_H(s)\cup A^{termination}_H(s), then (a\in A_{compensate}\cap (A^{fct}_H(s)\cap A^{directenc}(s)))\Rightarrow scp_c(trigger_c(a))\in A^{normal}(s) , i.e., a compensate activity is used to invoke compensation of a (descendant) scope nested in the normal process of scope s only,$

\item $LR\subseteq A\times L\times A is a labeled acyclic graph which defines the relation between the source
activity of a control link and the target activity of the link, $
\item $The boundary crossing restrictions for a control link are defined as follows:$
\begin{itemize}
	\item $\forall_{(a,l,a')\in LR}(a\notin clan(a')), i.e., a control link cannot connect an activity to any of its ancestors,$
	\item $\forall_{s \in A_{sequence}}\forall_{\{x,x'\}\subseteq children(a)}\forall_{a\in clan(x)}\forall_{a'\in clan(x')}(x<^s_{seq}x'\Rightarrow \neg \exists_{l\in L}LR(a',l,a))), i.e., in a se-
quence activity a control link cannot connect a sub-activity or any of its descendants to any
preceding sub-activity or any of its descendants,$
\item $...$
\end{itemize}
\item $let A^{source}=\{a\in A|\exists_{l\in L}((a,l)\in\pi_{1,2}LR)\} be a set of source activities of all control links, and A^{target}=\{a\in A|\exists_{l\in L}((l,a)\in \pi_{2,3}LR)\} be a set of target activities of all control links, then \forall a\in A^{source},L_{out}(a)=\{l\in L|\exists_{a'\in A}LR(a,l,a')\} is a set of all outgoing control links from a,
and \forall a\in A^{target}, L_{in}(a)=\{l\in L|\exists_{a'\in A}LR(a',l,a)\} is a set of all incoming control links to a,$
\item $let a\in A^{target}, joincon(a), which expresses the join condition of incoming control links at a, is a
boolean function over L_{in}(a)(i.e. Var(joincon(a))=L_{in}(a))$
\end{itemize}
\end{definition}

\subsection{Statement Coverage}
Bei der Statementabdeckung geht es darum, festzustellen, wie viele der Statements beim Testen ausgeführt wurden. Die Basisaktivitäten der WS-BPEL entsprechen den Anweisungen der anderen Programmiersprachen. Aus diesem Grund kann die allgemein bekannte Definition der Statementabdeckung einfach für BPEL übernommen werden. Damit die Statistik etwas differenzierter ist,  wird Metrik für die einzelne Basisaktivitäten definiert:

Die gesamte Statementabdeckung bezieht sich auf alle Basisaktivitäten:

Die vorgestellten Anweisungsabdeckungsmetriken berücksichtigen nach Definition von HR, HBR und der Funktion   auch Basisaktivitäten, die in sämtlichen Handler verwendet werden. 
Es sollte beim Testen mindestens sichergestellt werden, dass alle Basisaktivitäten, die die elementaren Aktivitäten eines Prozesses sind, durch die Tests abgedeckt sind. Die Statementabdeckung ist dennoch ein schwaches Kriterium, weil dabei nur die einzelnen Anweisungen betrachtet, ohne Zusammenhänge zu berücksichtigen.
\subsection{Branch Coverage}
Die Zweigabdeckung betrachtet das Verhältnis von durchlaufenen Zweigen zu allen möglichen Zweigen des Testobjekts. Die strukturierten Aktivitäten bestimmen den Kontrollfluß in WS-BPEL und definieren damit die Zweige der Kontrollstruktur. 
Um diese Metrik für WS-BPEL zu definieren, werden zwei Funktionen eingeführt:

ist die Scope-Aktivität an der Wurzel des Baumes, der durch die Schachtelung von Aktivitäten entsteht. Nach der Definition beinhaltet process-Aktivität alle Aktivitäten des WS-BPEL Prozesses. Dementsprechend kann die Zweigabdeckung für einen WS-BPEL Prozess folgendermaßen definiert werden:  

Obwohl die Fehlererkennungsquote gegenüber der Anweisungsabdeckung steigt, werden nicht alle Aspekte des Kontrollflusses erfasst. Während jeder Zweig für sich alleine betrachtet wird, bleiben die Kombinationen von Zweigen unberücksichtigen.  
\subsection{Link Coverage}
Das Link-Konzept ist in WS-BPEL ein wichtiges aber komplexes Modellierungsmittel. Die Links dienen der Synchronisation zwischen Aktivitäten und  können mit Hilfe von transition und joinConditions Bedingungen für die Ausführung der Zielaktivität festlegen. Die mit diesen Konstrukten umgesetzte Logik erfordert eine besondere Beachtung beim Testen. 
Für die Definition einer entsprechenden Metrik muss die Auswertungsfunktion für transitionCondition etwas genauer betrachtet werden. Die Zuordnung des booleschen Wertes dem Link durch transitionCondition  kann auf zwei verschiedenen Weisen stattfinden: entweder ist der Wert konstant und schon vor der Ausführung bekannt, oder er wird zur Laufzeit durch die Auswertung des zugeordneten booleschen Ausdrucks bestimmt. Für die Tests sind insbesondere die Links relevant, deren transitionCondition erst zur Laufzeit ausgewertet wird. Es ist dabei wichtig, dass der Ausdruck sowohl zu true als auch zu false ausgewertet wird.

\subsection{Handler Coverage}
WS-BPEL Sprache hat ein Konzept zur strukturierten Behandlung von Laufzeitfehlern. Im Rahmen einer Fehlerbehandlung ist es möglich, die eigentlich in sich erfolgreichen Aktionen rückgängig zu machen. Dafür sind CompensationHandler in WS-BPEL vorgesehen. Da die Geschäftsprozesse in der Regel langlebig sind und sensitive Daten verarbeiten können, muss das Verhalten des Systems im Fehlerfall umfassend getestet werden. Die in diesem Abschnitt vorgestellten Metriken können dabei als Indikator für die Testqualität bezüglich der Fehlerbehandlung und Kompensation dienen.
FaultHandler. 
Eine wichtige Information ist zum Beispiel, ob alle durch den Programmierer vorgesehen Fehlerbehandlungen in Form von catch- bzw catchAll-Blöcken durch die Tests stimuliert werden. 

\section{Example [AS+DL]} [1.5 pages]
\section{Software Support} [DL] [1 page]
\section{Conclusions and Outlook} [DL] [0.5 pages]

%
% ---- Bibliography ----
%
\begin{thebibliography}{}
%
\bibitem[1980]{2clar:eke}
Clarke, F., Ekeland, I.:
Nonlinear oscillations and
boundary-value problems for Hamiltonian systems.
Arch. Rat. Mech. Anal. {\bf 78} (1982) 315--333

\bibitem[1981]{2clar:eke:2}
Clarke, F., Ekeland, I.:
Solutions p\'{e}riodiques, du
p\'{e}riode donn\'{e}e, des \'{e}quations hamiltoniennes.
Note CRAS Paris {\bf 287} (1978) 1013--1015

\bibitem[1982]{2mich:tar}
Michalek, R., Tarantello, G.:
Subharmonic solutions with prescribed minimal
period for nonautonomous Hamiltonian systems.
J. Diff. Eq. {\bf 72} (1988) 28--55

\bibitem[1983]{2tar}
Tarantello, G.:
Subharmonic solutions for Hamiltonian
systems via a $\bbbz_{p}$ pseudoindex theory.
Annali di Matematica Pura (to appear)

\bibitem[1985]{2rab}
Rabinowitz, P.:
On subharmonic solutions of a Hamiltonian system.
Comm. Pure Appl. Math. {\bf 33} (1980) 609--633

\end{thebibliography}
\clearpage
\addtocmark[2]{Author Index} % additional numbered TOC entry
\renewcommand{\indexname}{Author Index}
\printindex
\clearpage
\addtocmark[2]{Subject Index} % additional numbered TOC entry
\markboth{Subject Index}{Subject Index}
\renewcommand{\indexname}{Subject Index}
\input{subjidx.ind}
\end{document}

