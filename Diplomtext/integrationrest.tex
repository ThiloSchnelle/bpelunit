Ein BPEL-Prozess besteht aus der Geschäftslogik (definiert in BPEL), Servicebeschreibung (WSDL) und optional aus weiteren Datentypen (XML Schema). Diese Informationen werden zusammengefasst und in eine BPEL Engine deployt. Die Engine ist unter anderem dafür verantwortlich, die \textit{Endpoints} der Partner des BPEL Prozesses zu spezifizieren. Für jeden Link muss bekannt sein, welche WSDL service und port und welche Adresse für die Kommunikation benutzt werden sollen. Diese Information wird in so genannten Deployment descriptoren festgelegt.
   Das Deployment und die Syntax der Deploymentdescriptoren ist nicht spezifiziert.



Für das Testen, wie bereits erläutert, muss BPEL-Prozess in eine Engine deployt werden. Die BPEL-Dateien mit  den Deploymentinformation werden in einem Archive zusammengefasst und an die BPEL Engine übergeben. Damit der Web Service für den BPEL-Prozess erreichbar ist, muss die WSDL Beschreibung des Web Services in dem Archive enthalten sein. Außerdem muss für die Kommunikation mit diesem Web service ein PartnerLink definiert. Für diesen Link muss in dem Deployment descriptor die WSDL service und port sowie die konkrete Adresse (in diesem Fall eine feste Adresse auf dem lokalen Host) festgelegt werden.
   Das Deployment und die Syntax der Deploymentdescriptoren ist nicht spezifiziert.

PARTNERLINKTYPE wird in der WSDL Platziert

 Hierzu müssen von der jeweiligen BPEL Engine abhängige Deployment-Informationen bereitgestellt werden. 

In disem Abschnitt werden zuerst zwei Möglichkeiten für die Integration der Messung der Testabdeckung in das Framework vorgestellt. Nach einem Vergleich der beiden Ansätze wird einen als Lösung ausgewählt

Die Aufgabe 

die SOAP-Nachrichten, die an Coverage Receiver gerichtet sind müssen dekodiert werden und  an den Servece (Mock) weitergeleitet werden.  

Ansatz1
Es kann ein spezieller Partner Track für den Service definiert und zu jedem TestCase zugeordnet werden. Zu jedem TestCase kann dann ein Thread gestartet werden, der die Coverage Nachrichten empfängt. Es reicht aus jedem TestCase aus. Es muss die Logik für den Manager der Marken implementiert werden. Dafür kann entweder die receive Aktivität mehrmals hintereinander geschaltet werden, oder eine neue Aktivität, die alle Nachrichten akzeptiert.



 Das Framework dekodiert und leitet weiter , man braucht sich keine Gedanken zu machen. 

nachteil größere Eingriffe in das Framework und an vielen Stellen:
\begin{itemize}
	\item beim Start jedes Testcases muss ein zusätzliches Thread gestartet werden
	\item beim shutdown unberücksichtigt 
	\item beim Auswerten des Ergebnissen muss dieser Thread unberücksichtigt bleiben 
\end{itemize}



Ansatz2

Direkt nachdem Empfangen der Nachricht wird diese an den Receiver weitergeleitet. Dieser muss sich um die Dekodierung der SOAP Nachrichten kümmern


Dadurch dass beim ersten Ansatz die ganze Funktionalität  der Kommunikation (der Übermittlung und Dekodierung der Nachrichten) durch das Framework erledigt werden erscheint diese Möglichkeit als eleganter. Aber Velangsamen