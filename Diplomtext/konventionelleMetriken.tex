 In diesem Abschnitt werden die Metriken für die Messung der Testabdeckung in BPEL definiert. Dabei werden die in Abschnitt \ref{Abdeckungsmetriken} beschrieben Abdeckungsmetriken an BPEL-Kontext angepasst und neue spezifische Metriken eingeführt.  Bei allen Metriken wurde darauf geachtet, dass die 100\% Abdeckung beim Testen erreicht werden kann. 

  \subsection{Aktivitätabdeckung}
  Mit BPEL lässt sich ein Prozess beschreiben, der in der Lage ist, verschiedene Dienste (Web SerServices) zu einer Gesamtanwendung zu verknüpfen. Die Kommunikation mit den Diensten wird durch Basisaktivitäten realisiert. Die Basisaktivitäten sind die elementaren Aktivitäten eines Prozesses, die keine weiteren Aktivitäten enthalten. 
 
 Bei der Statementabdeckung geht es darum, festzustellen, wie viele der
Anweisungen beim Testen ausgeführt wurden. Da die Basisaktivitäten der WS-BPEL
 den Anweisungen der anderen Programmiersprachen ent\-spre\-chen, kann die Anweisungsabdeckung als Ausgangspunkt für die Definition der Aktivitätabdeckung dienen.
 
 Insbesondere ist diese Statistik im Bezug auf einzelne Aktivitäten interessant. So ist die Information, ob alle \textit{Invokes} (Web Service-Aufrufe) beim Testen ausgeführt wurden, sehr wichtig, um die erste Einschätzung über die Testqualität zu machen. In dieser Hinsicht ist die Definition der Abdeckungsmetriken für die einzelnen Basisaktivitäten sinnvoll.
\begin{Def}    
\begin{itemize}
	\item $\forall t\in \mathcal{T}_\mathcal{B},\ \mathcal{A}^{executed}_t$ ist die Menge der Basisaktivitäten vom Typ $t$, die beim Testen ausgeführt wurden. Somit kann die Aktivitätabdeckung für alle Basisaktivitäten wie folgt definiert werden:
		\[
	\mathcal{S}_t(\mathcal{W})=\frac{\left| \mathcal{A}^{executed}_t\right|}{ \left|\mathcal{A}_t\right|},\ \forall t\in \mathcal{T}_\mathcal{B}
\]

Die gesamte Statementabdeckung bezieht sich auf alle Basisaktivitäten:
	\[
	\mathcal{S}(\mathcal{W})=\frac{\left|\bigcup_{t\in \mathcal{T}_\mathcal{B}} \mathcal{A}^{executed}_t\right|}{ \left|\mathcal{A}^{basic}\right|}
\]
\end{itemize}
\end{Def}

Zu bemerken ist, dass die Basisaktivitäten, die in sämtlichen Handler verwendet werden, nach Definition der Mengen $\mathcal{A}_t$, $\mathcal{A}^{executed}_t$ und $\mathcal{A}^{basic}$ in den Anweisungsabdeckungsmetriken berücksichtigt werden. 

Es sollte beim Testen mindestens sichergestellt werden, dass alle
Basisaktivitäten, die die elementaren Aktivitäten eines Prozesses sind, durch
die Tests abgedeckt sind. Die Anweisungsabdeckung ist dennoch ein schwaches
Kriterium, weil dabei nur die einzelnen Anweisungen betrachtet, ohne
Zusammenhänge zu berücksichtigen.    

\subsection{Zweigabdeckung}
Die Zweigabdeckung beschreibt das Verhältnis von durchlaufenen Zweigen zu allen
möglichen Zweigen des BPEL-Prozesses. Wie bereits im Abschnitt \ref{bpelformal}
erklärt, werden die Zweige durch Relationen $\mathcal{HR}$ und $\mathcal{HBR}$
beschrieben. Die Funktion $branch\_executed$ bestimmt welche Zweige beim Testen
durchlaufen wurden und wird wie folgt definiert:      
\begin{itemize}
	\item $branch\_executed:\mathcal{HR}\cup \mathcal{HBR}\rightarrow \mathcal{B}$,
	\item $\forall r\in \mathcal{HR}\cup \mathcal{HBR},\ branch\_executed(r)=true$ nur wenn die Relation r beim Testen verwendet wurde.
\end{itemize}
Außerdem werden folgende Funktionen eingeführt:
\begin{itemize}
\item 
sei $\mathcal{A}_i\subseteq\mathcal{A},\ s\in \mathcal{A}_i,\ t=type_\mathcal{A}(s)$
	\item $br\_number_{set}(\mathcal{A}_i)=\sum_{s\in\mathcal{A}_i}br\_number_t(s)$ berechnet für eine Menge von Aktivitäten, die Zweige in der Kontrollstruktur, die durch diese Aktivität beschrieben werden,
	\item $ex\_br\_number_{set}(\mathcal{A}_i)=\sum_{s\in \mathcal{A}_i}ex\_br\_number_t(s)$ berechnet für eine Menge von Aktivitäten die Anzahl der Zweige, die beim Testen durchlaufen wurden.
\end{itemize}
Es folgt die Definition der entsprechenden Funktionen für alle Typen der Aktivitäten:
\begin{itemize}
	\item sequence:
	\begin{itemize}
	\item $br\_number_{sequence}(s)=\left|children(s)\right|-1+	br\_number_{set}(children(s)),\ s \in \mathcal{A}_{sequence}$
	\item $EX^{s}_{seq}=\{(s,b,a)\in \mathcal{HR}|s \in \mathcal{A}_{sequence}\wedge \exists_{a_k\in children(s)}(a_k <^{s}_{seq}a)\wedge branch\_executed((s,b,a))=true \}$
	\item $ex\_br\_number_{sequence}(s)=\left|EX^{s}_{seq}\right|+ex\_br\_number_{set}(children(s))$
\end{itemize}
\item if:
	\begin{itemize}
	\item $br\_number_{if}(s)=\left|children(s)\right|+br\_number_{set}(children(s)),\ s \in \mathcal{A}_{if}$
	\item $EX^{s}_{if}=\{(s,b,a)\in \mathcal{HR}|s \in \mathcal{A}_{if}\wedge branch\_executed((s,b,a))=true \}$
		\item $ex\_br\_number_{if}(s)=\left|EX^{s}_{if}\right|+ex\_br\_number_{set}(children(s))$
\end{itemize}
\item pick:
	\begin{itemize}
	\item $br\_number_{pick}(s)=\left|children(s)\right|+br\_number_{set}(children(s)),\ s \in \mathcal{A}_{pick}$
	\item $EX^{s}_{pick}=\{(s,b,a)\in \mathcal{HR}|s \in \mathcal{A}_{pick}\wedge branch\_executed((s,b,a))=true \}$
		\item $ex\_br\_number_{pick}(s)=\left|EX^{s}_{pick}\right|+ex\_br\_number_{set}(children(s))$
\end{itemize}
\item loops ($\forall t\in\{while,\ repeatUntil,\ forEach\}$):
	\begin{itemize}
	\item $br\_number_{t}(s)=2+br\_number_{set}(children(s)),\ s \in \mathcal{A}_{t}$
	\item $EX^{s}_{1}=\{(s,b,a)\in \mathcal{HR}|s \in \mathcal{A}_{t}\wedge branch\_executed((s,b,a))=true \}$
	\item $EX^{s}_{2}=\{(a,b,s)\in \mathcal{HBR}|s \in \mathcal{A}_{t}\wedge branch\_executed((s,b,a))=true \}$
	\item $EX^{s}_{t}=EX^{s}_{1}+EX^{s}_{2}$
		\item $ex\_br\_number_{t}(s)=\left|EX^{s}_{t}\right|+ex\_br\_number_{set}(children(s))$
\end{itemize}
\item flow:
	\begin{itemize}
	\item $br\_number_{flow}(s)=\left|children(s)\right|+br\_number_{set}(children(s)),\ s \in \mathcal{A}_{flow}$
	\item $EX^{s}_{flow}=\{(s,b,a)\in \mathcal{HR}|s \in \mathcal{A}_{flow}\wedge branch\_executed((s,b,a))=true \}$
		\item $ex\_br\_number_{flow}(s)=\left|EX^{s}_{flow}\right|+ex\_br\_number_{set}(children(s))$
\end{itemize}
\item scope:
	\begin{itemize}
	\item $br\_number_{flow}(s)=br\_number_{set}(children(s)),\ s \in \mathcal{A}_{scope}$
		\item $ex\_br\_number_{scope}(s)=ex\_br\_number_{set}(children(s))$\\
	Bemerkung: alle Zweige innerhalb von Handlern gehen in die Rechnung ein, weil nach Definition von $\mathcal{A}_{scope}$ alle Handler in der Menge $children(scope)$ enthalten sind,
\end{itemize}
\item Basisaktivitäten ($\forall t\in \mathcal{T}_\mathcal{B}$):
	\begin{itemize}
	\item $br\_number_{t}(s)=0,\ s \in \mathcal{A}^{basic}$
	\item $ex\_br\_number_{t}(s)=0,\ s \in \mathcal{A}^{basic}$
\end{itemize}
\end{itemize}

$process$ ist die Scope-Aktivität an der Wurzel des Baumes, der durch die Schachtelung von Aktivitäten entsteht. Nach der Definition beinhaltet process-Aktivität alle Aktivitäten des WS-BPEL Prozesses. Dementsprechend kann die Zweigabdeckung für einen WS-BPEL Prozess folgendermaßen definiert werden:  
\[
\mathcal{B}=\frac{ex\_br\_number_{scope}(process)}{br\_number_{scope}(process)}
\]

Die Abbildung \ref{fig:ExamlpleBPELProzess} verdeutlicht an einem Beispiel welche Kontrollflusszweige durch die Metrik abgedeckt sind. Die dickeren Pfeile markieren den Ausführungspfad. Während alle durchgezogenen Kanten dieses Pfades (auch in \textit{Fault}- und \textit{CompensationHandler}) für die Zweigabdeckung relevant sind, gehen die gestrichelten nicht in die Rechnung ein. Die Übergabe der Kontrolle in einem Fehlerfall an die entsprechenden Handler bleibt unberücksichtigt.
\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.9\textwidth]{bilder/Fault_Compensation.png}
		\caption{Kontrollfluss eines BPEL Prozesses}
	\label{fig:ExamlpleBPELProzess}
\end{figure}

Obwohl die Fehlererkennungsquote gegenüber der Anweisungsabdeckung steigt, werden nicht alle Aspekte des Kontrollflusses erfasst. Während jeder Zweig für sich alleine betrachtet wird, bleiben die Kombinationen von Zweigen unberücksichtigt. 

In den nächsten beiden Abschnitten werden die für WS-BPEL spezifischen
Testabdeckungsmetriken vorgestellt: Link- und Handlerabdeckung.      

\subsection{Link Abdeckung}
Das Link-Konzept ist in WS-BPEL ein wichtiges aber komplexes Modellierungsmittel. Die Links dienen der Synchronisation zwischen parallelen Aktivitäten. Das Verhalten der Links kann mit Hilfe von \textit{transition} und \textbf{joinCondition} kontrolliert werden. Durch diese Bedingungen ist es möglich komplexe Logik zu modellieren. Daraus ergibt sich die zwingende Notwendigkeit die Links und deren Verhalten zu testen. 
 
Für die Definition einer entsprechenden Metrik wird eine Auswertungsfunktion
definiert). Let $f$ be a boolean function (or propositional statement),
$Var(f)$ yields all the propositional variables used in $f$ . Let $F$ be a set
of boolean functions and $B$ be the boolean set (true, false), a variable
assignment of $F$ is a mapping $assign: Var(F)\rightarrow B$, and the set of
all possible variable assignments of $F$ is denoted by $Assign(F)$. An
evaluation function is a mapping $eval: F \times Assign(F)\rightarrow B$
(\cite{Ouyang2005}).

Für die Tests sind nur die Links relevant, deren transition condition nicht mit
einem konstanten Wert belegt sind, sondern mit einem Ausdruck, der erst zur
Laufzeit ausgewertet werden kann. Es ist dabei wichtig, dass der Ausdruck
sowohl zu $true$ als auch zu $false$ ausgewertet wird, um das Verhalten in beiden Fällen zu testen.

Die entsprechende Metrik heißt $Link\ Coverage$ und wird wie folgt definiert:
\begin{itemize}
	\item $l \in_{\pi 2}\mathcal{LR}$,
	\item $f=transcon(l)$,
	\item $Assign_{test}\subseteq Assign(f)$ die Menge der Kombinationen von Variablenbelegungen, die beim Testen stattgefunden sind,
\end{itemize}
\begin{equation*}
\begin{split}
\mathcal{L}=\frac{\{\left|l\in_{\pi 2}\mathcal{LR}|Var(f)\neq \emptyset\wedge eval(f,Assign_{test}(Var(f))=true)\right|
}{2*\left|\{l\in_{\pi 2}\mathcal{LR}|Var(f)\neq \emptyset \}\right|}+
\\\frac{\{\left|l\in_{\pi 2}\mathcal{LR}|Var(f)\neq \emptyset\wedge eval(f,Assign_{test}(Var(f))=false)\right|\}}{2*\left|\{l\in_{\pi 2}\mathcal{LR}|Var(f)\neq \emptyset \}\right|}
\end{split}
\end{equation*}
	Damit es möglich ist, die 100\%  Abdeckung dieser Metrik zu erreichen, werden nur die Links berücksichtigt, derenn transition condition mindestenns eine Variable enthält ($Var(f)\neq \emptyset$).
	
	Außerdem ist es wichtig, dass nur die Links beachtet werden, deren transition condition beim Testen ausgewertet wurde und nicht durch $DPE$ auf $false$ gesetzt wurde. Anderenfalls können sehr einfache Tests, die die zugehörige Logik nicht testen, sehr schnell 50\% Abdeckung dieser Metrik erreichen. So eine Metrik würde dem Verhältnis zwischen Abdeckung und Testqualität (siehe Abschnitt ) widersprechen.

\subsection{Fault und Compensation Handler Abdeckung}
WS-BPEL Sprache hat ein Konzept zur strukturierten Behandlung von
Laufzeitfehlern. Die Umschaltung von normalen auf \textit{FaultHandler-}Kontrollfluss erfolgt automatisch beim Auftreten eines Fehlers. Was nichts anderes heißt, als dass der zugehörige \textit{FaultHandler} ausgeführt wird. Die Fehler können auch in den \textit{Compensation} und in den \textit{FaultHandler} selbst auftreten. Die Tatsache, dass die
BPEL-Prozesse langlebig sein können und in unternehmenskritische Bereichen eingesetzt werden, verdeutlicht die Notwendigkeit, das Verhalten des Systems auch im
Fehlerfall umfassend zu testen. Demzufolge sollten die entsprechenden Handler durch die Tests abgedeckt werden. Die in diesem Abschnitt vorgestellten Metriken
können dabei als Indikator für die Testqualität bezüglich der Fehlerbehandlung und Kompensation dienen.

\textbf{FaultHandler.} Eine wichtige Information beim Testen des Systems im
Fehlerfall ist, ob alle  $catch$- bzw $catchAll$-Blöcken durch die Tests
ausgeführt werden.   

\begin{itemize}
	\item $A_{catch}=\{a\in \mathcal{A}^{structured}\cup \mathcal{A}^{basic}|(s,f,a)\in \mathcal{HR}\wedge f\in \mathcal{E}_{fault}\wedge s\in \mathcal{A}_{scope}\}$ die Menge der top-level Aktivitäten in allen $catch$- und $catchAll$-Blöcken, 
	\item $\left|A_{catch}\right|$ entspricht der Anzahl von catch- und catchall-Blöcken
	\item $A^{executed}_{catch}=\{a\in A_{catch}|\exists (s,f,a)\in \mathcal{HR}\wedge branch\_executed((s,f,x))=true\}$ die Teilmenge der Aktivitäten aus $A_{catch}$, die getestet wurden,
\end{itemize}
\[
FH=\frac{\left|A_{catch}\right|}{\left|A^{executed}_{catch}\right|}
\]

Im Rahmen einer Fehlerbehandlung ist es möglich, die
eigentlich in sich erfolgreichen Aktionen rückgängig zu machen. Dafür sind in
WS-BPEL die Compensation Handler vorgesehen.
\textbf{Compensation Handler.}
\begin{itemize}
	\item $A_{compensation}=\{a\in \mathcal{A}^{structured}\cup \mathcal{A}^{basic}|(s,c,a)\in \mathcal{HR}\wedge c\in \mathcal{E}_{compensate}\wedge s\in \mathcal{A}_{scope}\}$ die Menge der top-level Aktivitäten in allen Compensation Handler
	\item $\left|A_{compensation}\right|$ entspricht der Anzahl der Compensation Handler
	\item $A^{executed}_{compensation}=\{a\in A_{compensation}|\exists (s,c,a)\in \mathcal{HR}\wedge branch\_executed((s,c,a))=true\}$ die Teilmenge der Aktivitäten aus $A_{compensate}$, die getestet wurden,
\end{itemize}
\[
CH=\frac{\left|A^{executed}_{compensation}\right|}{\left|A_{compensation}\right|}
\]

Da die Geschäftsprozesse in der Regel langlebig sind und darüber hinaus sensitive
Daten verarbeiten können, ist eine ausreichende Fehlerbehandlung zwingend notwendig.
Im Rahmen einer Fehlerbehandlung ist oft das Zurücksetzen vorangegangener Änderungen erwünscht. Dafür sind CompensationHandler in BPEL vorgesehen, die das Rückgängig-machen von eigentlich in sich erfolgreichen Aktionen übernehmen.

Aufgrund dieser besonderen Wichtigkeit der Fehlerbehandlung muss das Verhalten des Systems im Fehlerfall umfassend getestet werden. Die in diesem Abschnitt vorgestellten Metriken können dabei als Indikator für die Testqualität bezüglich der Fehlerbehandlung und Kompensation dienen.
 
\textbf{FaultHandler.}
Eine wichtige Information ist zum Beispiel, ob alle durch den Programmierer vogesehen Fehlerbehandlungen in Form von \textit{catch}- bzw \textit{catchAll}-Blöcken durch die Tests stimuliert werden. 
Die folgende Definition legt die dazugehörige Metrik fest: 
\[
	FaultHandlerAbdeckung=\frac{\text{Anzahl der getesten \textit{catch}- und \textit{catchAll}-Blöcken }}{\text{Anzahl der \textit{catch}- und \textit{catchAll}-Blöcken}}
\]

Die impliziten \textit{FaultHandler} werden nicht berücksichtigt. Die sogenannten \textit{Inline-FaultHandler}, die direkt in die \textit{invok}e-Aktivitäten integriert sind, müssen dagegen in die Berechnung einfließen.

\textbf{Compensation Handler.}
Diese Metrik gibt den Abdeckungsgrad der \textit{CompensationHandler} an: 
\[
	CompensateHandlerAbdeckung=\frac{\text{Anzahl der getesten \textit{CompensationHandler}}}{\text{Anzahl der \textit{CompensationHandler}}}
\]
Die \textit{Inline-CompensateHandler} werden ebenfalls berücksichtigt. \\
\\




