 In diesem Abschnitt werden die Metriken für die Messung der Testabdeckung in BPEL definiert. Dabei werden die Statement- und Zweigabdeckung (siehe Abschnitt \ref{Abdeckungsmetriken}) an BPEL-Kontext angepasst und neue BPEL-spezifische Metriken eingeführt.  
 Die Metriken dienen als Mittel für die Bestimmung der Qualität und des Fortschritts der Tests. Dabei bezieht sich jede Metrik auf bestimmte Aspekte des Kontrollflusses.
 
 Bei allen Metriken wurde darauf geachtet, dass die 100\% Abdeckung beim Testen erreicht werden kann. Zwischen dem ermittletem Wert einer Metrik und der Testqualität gibt es einen einfachen Zusammenhang; je größer der Wert ist, desto höher ist die Qualität der Tests im Bezug auf Aspekte des Kontrollflusses, die die Metrik festlegt.

  \subsection{Aktivitätabdeckung}
  Mit BPEL lässt sich ein Prozess beschreiben, der in der Lage ist, verschiedene Dienste (Web SerServices) zu einer Gesamtanwendung zu verknüpfen. Die Kommunikation mit den Diensten wird durch Basisaktivitäten realisiert. Die Basisaktivitäten sind die elementaren Aktivitäten eines Prozesses, die keine weiteren Aktivitäten enthalten. 
 
 Bei der Statementabdeckung geht es darum, festzustellen, wie viele der
Anweisungen beim Testen ausgeführt wurden. Da die Basisaktivitäten der WS-BPEL
 den Anweisungen der anderen Programmiersprachen ent\-spre\-chen, kann die Anweisungsabdeckung als Ausgangspunkt für die Definition der Aktivitätabdeckung dienen.
 
 Insbesondere ist diese Statistik im Bezug auf einzelne Aktivitäten interessant. So ist die Information, ob alle \textit{Invokes} (Web Service-Aufrufe) beim Testen ausgeführt wurden, sehr wichtig, um die erste Einschätzung über die Testqualität zu machen. In dieser Hinsicht ist die Definition der Abdeckungsmetriken für die einzelnen Basisaktivitäten sinnvoll.
\begin{Def}
 $\forall t\in \mathcal{T}_\mathcal{B},\ \mathcal{A}^{executed}_t\subseteq A^{basic}$ ist die Menge der Basisaktivitäten vom Typ $t$, die beim Testen ausgeführt wurden. Somit kann die Aktivitätabdeckung für alle Basisaktivitäten wie folgt definiert werden:
		\[
	\mathcal{S}_t(\mathcal{W})=\frac{\left| \mathcal{A}^{executed}_t\right|}{ \left|\mathcal{A}_t\right|},\ \forall t\in \mathcal{T}_\mathcal{B}
\]

Die gesamte Statementabdeckung bezieht sich auf alle Basisaktivitäten:
	\[
	\mathcal{S}(\mathcal{W})=\frac{\left|\bigcup_{t\in \mathcal{T}_\mathcal{B}} \mathcal{A}^{executed}_t\right|}{ \left|\mathcal{A}^{basic}\right|}
\]
\end{Def}

Zu bemerken ist, dass die Basisaktivitäten, die in sämtlichen Handler verwendet werden, nach Definition der Mengen $\mathcal{A}_t$, $\mathcal{A}^{executed}_t$ und $\mathcal{A}^{basic}$ durch die Aktivitätsabdeckungsmetriken berücksichtigt werden. 

Es sollte beim Testen mindestens sichergestellt werden, dass alle
Basisaktivitäten, die die elementaren Aktivitäten eines Prozesses sind, durch
die Tests abgedeckt sind. Die Aktivitätsabdeckung ist dennoch ein schwaches
Kriterium, weil dabei nur die einzelnen Basisaktivitäten betrachtet werden, ohne
Zusammenhänge zu berücksichtigen.    


\subsection{Zweigabdeckung}
Die Zweigabdeckung beschreibt das Verhältnis von durchlaufenen Zweigen zu allen
möglichen Zweigen des BPEL-Prozesses. Wie bereits im Abschnitt \ref{bpelformal}
erklärt, werden die Zweige durch Relationen $\mathcal{HR}$ und $\mathcal{HBR}$
beschrieben. Die Funktion $BE$ (branch executed) bestimmt welche Zweige beim Testen
durchlaufen wurden und wird wie folgt definiert:      
\begin{itemize}
	\item $BE:\mathcal{HR}\cup \mathcal{HBR}\rightarrow \mathcal{B}$,
	\item $\forall r\in \mathcal{HR}\cup \mathcal{HBR},\ BE(r)=true$
	nur wenn die Relation $r$ beim Testen verwendet wurde.
\end{itemize}


Außerdem werden folgende Funktionen eingeführt:
\begin{itemize}
\item 
sei $\mathcal{A}_i\subseteq\mathcal{A},\ s\in \mathcal{A}_i,\ t=type_\mathcal{A}(s)$
	\item
	$br\_number_{set}(\mathcal{A}_i)=\sum_{s\in\mathcal{A}_i}br\_number_t(s)$
	berechnet für eine Menge von Aktivitäten, die Zweige in der Kontrollstruktur, die durch diese Aktivität beschrieben werden.
	\item $br\_number_{set}^{executed}(\mathcal{A}_i)=\sum_{s\in
	\mathcal{A}_i}br\_number_t(s)$ berechnet für eine Menge von Aktivitäten die Anzahl der Zweige, die beim Testen durchlaufen wurden.
\end{itemize}


Es folgt die Definition der entsprechenden Funktionen für alle Typen der Aktivitäten. Die Abbildung \ref{fig:flussgraphen} stellt die Kontrollflussgraphen der strukturierten Aktivitäten dar und soll dem Verständnis der Formel beitragen.
\begin{figure}
	\centering
		\includegraphics[width=0.95\textwidth]{bilder/Flussgraphen.png}
      \caption{Kontrollflussgraphen der Strukturierten Aktivitäten}
	\label{fig:flussgraphen}
\end{figure}
\begin{itemize}
	\item Sequence:
		\begin{itemize}
 			\item
 			$br\_number_{sequence}(s)=\left|children(s)\right|-1+br\_number_{set}(children(s)),\ s \in \mathcal{A}_{sequence}$ 
 			weil es einen Zweig zu jeder außer der ersten Aktivität gibt.
 			\item $EX^{s}_{seq}=\{(s,b,a)\in \mathcal{HR}|s \in \mathcal{A}_{sequence}\wedge \exists_{a_k\in children(s)}(a_k<^{s}_{seq}a)\wedge BE((s,b,a))=true \}$
 			\item
 				$br\_number^{executed}_{sequence}(s)=\left|EX^{s}_{seq}\right|+br\_number^{executed}_{set}(children(s))$
		\end{itemize}
	\item If:
		\begin{itemize}
		 	\item
 		 		$br\_number_{if}(s)=\left|children(s)\right|+br\_number_{set}(children(s)),\
	 			s \in \mathcal{A}_{if}$
 			\item $EX^{s}_{if}=\{(s,b,a)\in \mathcal{HR}|s \in \mathcal{A}_{if}\wedge
				BE((s,b,a))=true \}$
 			\item
          		$br\_number^{executed}_{if}(s)=\left|EX^{s}_{if}\right|+br\_number^{executed}_{set}(children(s))$
          		
       		\item \emph{Bemerkung:} Ein impliziter else-Zweig wird nach der formalen Definition von $If$-Aktivität automatisch berücksichtigt.
		\end{itemize}
\item Pick:
	\begin{itemize}
	\item $br\_number_{pick}(s)=\left|children(s)\right|+br\_number_{set}(children(s)),\ s \in \mathcal{A}_{pick}$
	\item $EX^{s}_{pick}=\{(s,b,a)\in \mathcal{HR}|s \in \mathcal{A}_{pick}\wedge BE((s,b,a))=true \}$
		\item $br\_number^{executed}_{pick}(s)=\left|EX^{s}_{pick}\right|+br\_number^{executed}_{set}(children(s))$
\end{itemize}
\item Loops ($\forall t\in\{while,\ repeatUntil,\ forEach\footnote{
Das Besondere an dieser Aktivität ist die Fähigkeit, den enthaltenen Scope nicht mehrmals hintereinander sondern parallel auszuführen (gesteuert mit Attribute \textit{parallel}). Diese Option bietet eine Möglichkeit die Abarbeitung des Prozesses zu beschleunigen. Diese Optimierungsmöglichkeit wird bei der Definition der Zweigabdeckung nicht berücksichtigt.}\}$):
	\begin{itemize}
	\item $br\_number_{t}(s)=2+br\_number_{set}(children(s)),\ s \in \mathcal{A}_{t}$
	\item $EX^{s}_{\mathcal{HR}}=\{(s,b,a)\in \mathcal{HR}|s \in \mathcal{A}_{t}\wedge BE((s,b,a))=true \}$
	\item $EX^{s}_{\mathcal{HBR}}=\{(a,b,s)\in \mathcal{HBR}|s \in \mathcal{A}_{t}\wedge BE((s,b,a))=true \}$
	\item $EX^{s}_{t}=EX^{s}_{\mathcal{HR}}+EX^{s}_{\mathcal{HBR}}$
		\item $br\_number^{executed}_{t}(s)=\left|EX^{s}_{t}\right|+br\_number^{executed}_{set}(children(s))$
\end{itemize}
\item Flow:
	\begin{itemize}
	\item $br\_number_{flow}(s)=\left|children(s)\right|+br\_number_{set}(children(s)),\ s \in \mathcal{A}_{flow}$
	\item $EX^{s}_{flow}=\{(s,b,a)\in \mathcal{HR}|s \in \mathcal{A}_{flow}\wedge BE((s,b,a))=true \}$
		\item $br\_number^{executed}_{flow}(s)=\left|EX^{s}_{flow}\right|+br\_number^{executed}_{set}(children(s))$
\end{itemize}
\item Scope:
	\begin{itemize}
	\item $br\_number_{flow}(s)=br\_number_{set}(children(s)),\ s \in \mathcal{A}_{scope}$
		\item $br\_number^{executed}_{scope}(s)=br\_number^{executed}_{set}(children(s))$\\
Bemerkung: alle Zweige innerhalb von Handlern gehen in die Rechnung ein, weil nach Definition von $\mathcal{A}_{scope}$ alle Handler in der Menge $children(scope)$ enthalten sind,
\end{itemize}
\item Basic Activities ($\forall t\in \mathcal{T}_\mathcal{B}$):
	\begin{itemize}
	\item $br\_number_{t}(s)=0,\ s \in \mathcal{A}^{basic}$
	\item $br\_number^{executed}_{t}(s)=0,\ s \in \mathcal{A}^{basic}$
\end{itemize}
\end{itemize}

$process$ ist die Scope-Aktivität an der Wurzel des Baumes, der durch die Schachtelung von Aktivitäten entsteht. Nach der Definition beinhaltet process-Aktivität alle Aktivitäten des WS-BPEL Prozesses. Dementsprechend kann die Zweigabdeckung für einen WS-BPEL Prozess folgendermaßen definiert werden: 
\[
\mathcal{B}(\mathcal{W})=\frac{br\_number^{executed}_{scope}(process)}{br\_number_{scope}(process)}
\]

Die Abbildung \ref{fig:ExamlpleBPELProzess} verdeutlicht an einem Beispiel welche Kontrollflusszweige durch die Metrik abgedeckt sind. Die dickeren Pfeile markieren den Ausführungspfad. Während alle durchgezogenen Kanten dieses Pfades (auch in \textit{Fault}- und \textit{CompensationHandler}) für die Zweigabdeckung relevant sind, gehen die gestrichelten nicht in die Rechnung ein. Die Übergabe der Kontrolle in einem Fehlerfall an die entsprechenden Handler bleibt unberücksichtigt.
\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.9\textwidth]{bilder/Fault_Compensation.png}
		\caption{Kontrollfluss eines BPEL Prozesses}
	\label{fig:ExamlpleBPELProzess}
\end{figure}

Obwohl die Fehlererkennungsquote gegenüber der Anweisungsabdeckung steigt, werden nicht alle Aspekte des Kontrollflusses erfasst. Während jeder Zweig für sich alleine betrachtet wird, bleiben die Kombinationen von Zweigen unberücksichtigt. 

In den nächsten beiden Abschnitten werden die für WS-BPEL spezifischen
Testabdeckungsmetriken vorgestellt: Link- und Handlerabdeckung. 

\subsection{Link Abdeckung}
Das Link-Konzept ist in WS-BPEL ein wichtiges aber komplexes Modellierungsmittel. Die Links dienen der Synchronisation zwischen parallelen Aktivitäten. Zusätzlich erlauben \textit{transition}- und \textit{join condition} das Verhalten der Links zu beeinflussen. Durch diese Bedingungen ist es möglich komplexe Logik zu modellieren. Daraus ergibt sich die zwingende Notwendigkeit die Links und deren Verhalten zu testen.  Das Ziel dieser Metrik ist, den Tester dazu zu bewegen, dass jede transition condition während der Tests mindestens einmal auf den Wert \textit{true} und einmal auf \textit{false} gesetzt wird.
 
Für die Definition einer entsprechenden Metrik wird eine Auswertungsfunktion
definiert). Sei $f$ eine boolsche Funktion (oder ein boolscher Ausdruck),
$Var(f)$ enthält aussagenlogische Variablen, die in $f$ vorkommen. Sei $F$ die Menge
der boolschen Funktionen und $B$ die Menge (\textit{true}, \textit{false}), dann ist die Variablenzuordnung von $F$ ist die Abbildung $assign: Var(F)\rightarrow B$, und eine Menge aller möglichen Variablenzuordnungen von $F$ ist $Assign(F)$. Die Auswertungsfunktion ist $eval: F \times Assign(F)\rightarrow B$
(\cite{Ouyang2005}).

Für die Tests sind nur die Links relevant, deren \textit{transition condition} nicht mit
einem konstanten Wert belegt sind, sondern mit einem Ausdruck, der erst zur
Laufzeit ausgewertet werden kann. Es ist dabei wichtig, dass der Ausdruck während der Ausführung
sowohl zu $true$ als auch zu $false$ ausgewertet wird, um das Verhalten in beiden Fällen zu testen.

Die entsprechende Metrik heißt \textit{Linkabdeckung} ($Link\ Coverage$) und wird wie folgt definiert:
\begin{itemize}
	\item $l \in_{\pi 2}\mathcal{LR}$,
	\item $f=transcon(l)$,
	\item $Assign_{test}\subseteq Assign(f)$ die Menge der Kombinationen von Variablenbelegungen, die beim Testen stattgefunden sind,
\end{itemize}
\begin{equation*}
\begin{split}
\mathcal{L}=\frac{\{\left|l\in_{\pi 2}\mathcal{LR}|Var(f)\neq \emptyset\wedge eval(f,Assign_{test}(Var(f))=true)\right|
}{2*\left|\{l\in_{\pi 2}\mathcal{LR}|Var(f)\neq \emptyset \}\right|}+
\\\frac{\{\left|l\in_{\pi 2}\mathcal{LR}|Var(f)\neq \emptyset\wedge eval(f,Assign_{test}(Var(f))=false)\right|\}}{2*\left|\{l\in_{\pi 2}\mathcal{LR}|Var(f)\neq \emptyset \}\right|}
\end{split}
\end{equation*}
	Damit es möglich ist, die 100\%  Abdeckung dieser Metrik zu erreichen, werden nur die Links berücksichtigt, derenn transition condition mindestenns eine Variable enthält ($Var(f)\neq \emptyset$). Ansonsten wäre es nicht möglich durch die Eingabedaten dafür zu sorgen, dass die \textit{transition}-Bedingung beim Testen sowohl \textit{true} als auch \textit{false}-Wert annimmt.
	
	Sobald das Link gesetzt ist ..................
	
	Außerdem ist es wichtig, dass nur die Links beachtet werden, deren \textit{transition condition} beim Testen ausgewertet wurde und nicht durch $DPE$ auf $false$ gesetzt wurde. Anderenfalls können sehr einfache Tests, die die zugehörige Logik nicht testen, sehr schnell 50\% Abdeckung dieser Metrik erreichen. Mit so einer Metrik sind keine zutreffenden Aussagen über die Testqualität möglich.

\subsection{Fault und Compensation Handler Abdeckung}
WS-BPEL Sprache hat ein Konzept zur strukturierten Behandlung von
Laufzeitfehlern. Die Umschaltung von normalen auf \textit{Fault Handler-}Kontrollfluss erfolgt automatisch beim Auftreten eines Fehlers. Was nichts anderes heißt, als dass der zugehörige \textit{Fault Handler} ausgeführt wird.  Die Tatsache, dass die
BPEL-Prozesse langlebig sein können und in geschägtskritische Bereichen eingesetzt werden, verdeutlicht die Notwendigkeit, das Verhalten des Systems auch im
Fehlerfall umfassend zu testen. Demzufolge sollten die entsprechenden Handler durch die Tests abgedeckt werden. Die in diesem Abschnitt vorgestellten Metriken
können dabei als Indikator für die Testqualität bezüglich der Fehlerbehandlung und Kompensation dienen.

\textbf{FaultHandler.} Eine wichtige Information beim Testen des Systems im
Fehlerfall ist, ob alle  $catch$- bzw $catchAll$-Blöcken durch die Tests
ausgeführt werden.   

\begin{itemize}
	\item $A_{catch}=\{a\in \mathcal{A}^{structured}\cup \mathcal{A}^{basic}|(s,f,a)\in \mathcal{HR}\wedge f\in \mathcal{E}_{fault}\wedge s\in \mathcal{A}_{scope}\}$ die Menge der top-level Aktivitäten in allen $catch$- und $catchAll$-Blöcken, 
	\item $\left|A_{catch}\right|$ entspricht der Anzahl von catch- und catchall-Blöcken
	\item $A^{executed}_{catch}=\{a\in A_{catch}|\exists (s,f,a)\in \mathcal{HR}\wedge BE((s,f,x))=true\}$ die Teilmenge der Aktivitäten aus $A_{catch}$, die getestet wurden,
\end{itemize}
\[
FH=\frac{\left|A_{catch}\right|}{\left|A^{executed}_{catch}\right|}
\]

Im Rahmen einer Fehlerbehandlung ist es möglich, die
eigentlich in sich erfolgreichen Aktionen rückgängig zu machen. Dafür sind in
WS-BPEL die Compensation Handler vorgesehen.

\textbf{Compensation Handler.} Die Tests sollten also nicht nur die Fehlersituationen provozieren sondern auch überprüfen, ob die entsprechenden Aktionen (in Form von \textit{Compenation Handler}) durchgeführt werden. 
\begin{itemize}
	\item $A_{compensation}=\{a\in \mathcal{A}^{structured}\cup \mathcal{A}^{basic}|(s,c,a)\in \mathcal{HR}\wedge c\in \mathcal{E}_{compensate}\wedge s\in \mathcal{A}_{scope}\}$ die Menge der top-level Aktivitäten in allen Compensation Handler
	\item $\left|A_{compensation}\right|$ entspricht der Anzahl der Compensation Handler
	\item $A^{executed}_{compensation}=\{a\in A_{compensation}|\exists (s,c,a)\in \mathcal{HR}\wedge BE((s,c,a))=true\}$ die Teilmenge der Aktivitäten aus $A_{compensate}$, die getestet wurden,
\end{itemize}
\[
CH=\frac{\left|A^{executed}_{compensation}\right|}{\left|A_{compensation}\right|}
\]


Damit die 100\% auch für diese Metriken erreichbar sind, werden die impliziten \textit{Fault-} und \textit{Compensation Handler} nicht berücksichtigt. Die sogenannten \textit{inline-Handler}, die direkt in die \textit{invoke}-Aktivitäten integriert sind, müssen dagegen in die Berechnung einfließen.




