Unit-Tests spielen eine sehr wichtige Rolle bei der Qualitätssicherung in der Softwareentwicklung. Um die Softwarequalität anhand der Test bewerten zu können, müssen zusätzliche Informationen über die Tests bekannt sein. Wichtig sind unter anderem die \textit{Anforderungs}- und \textit{Codeabdeckung} der Tests.
\begin{itemize}
	\item \textbf{Anforderungsabdeckung}(\textit{eng. requirements coverage}). Die Anforderungsabdeckung ist eine funktionale
Abdeckung auf Basis einer Spezifikation, die angibt, inwieweit die Testfälle alle Anforderungen abdecken. Diese Metrik wird meist im Zusammenhang mit \textit{Black-Box-Tests} verwendet. 
	\item \textbf{Codeabdeckung}(\textit{eng. code coverage}). Die Codeabdeckung ist eine Metrik für das Verhältnis zwischen
zu testenden und tatsächlich getesteten Elementen des Prüflings. Die Tests, die auf der Codeabdeckung basieren, gehören zur Gruppe der strukturorientierten Testtechniken und zielen darauf ab, die innere Struktur der Software zu testen (\textit{Glass-Box-Test}). 
\item Data Coverage Metrics measure how and when variables have been used in
a certain manner
\end{itemize}
Die \textit{Anforderungs}- und \textit{Codeabdeckung} sind Mittel zur Messung der Qualität bzw. Voll"-stän"-dig"-keit der Tests. Die beiden Testarten (\textit{Black-Box} und \textit{Glass-Box}) ergänzen sich gegenseitig und werden in der Regel kombiniert angewendet. Da für diese Arbeit nur die Codeabdeckung relevant ist, geht es im weiteren Verlauf des Dokuments nur um diesen Aspekt. Der Begriff \textit{Testabdeckung} wird ausschließlich als Synonym zu diesem Begriff verwendet. 

Die Unit-Tests werden verwendet, um sicherzustellen, dass der erstellte Code korrekt funktioniert. Jedoch lassen sich dabei nur Aussagen über die Codebereiche machen, die im Test aufgerufen oder, anders gesagt, durch den Test abgedeckt wurden. Das Ausführen aller potentiell fehlerhaften Stellen des Programms ist ein notwendiges Kriterium für das Finden der Fehler im Code. Deswegen ist die Angabe der erreichten Codeabdeckung aus der Sicht der Qualitätssicherung nicht nur sinnvoll sondern unabdingbar.

Bei der Analyse der Codeabdeckung geht es also darum festzustellen, wie gut die Codebereiche durch die Tests abgedeckt sind bzw. welche Bereiche gar nicht oder nicht ausreichend abgedeckt sind. Wenn ein Testentwickler auf diese Information ständig und einfach zugreifen kann, dann hat er die Möglichkeit, neue Tests gezielt zu erstellen. Dadurch kann die Qualität der Tests schrittweise erhöht und die Erstellung der überflüssigen Tests vermieden werden. Mit Hilfe der Codeabdeckung kann also ein Optimum zwischen dem wirtschaftlichen Aufwand und der Testqualität gefunden werden, was bei der Herstellung der Software auch ein wichtiger Aspekt ist. 

In der folgenden Aussage werden die drei Begriffe \textit{Codeabdeckungsanalyse}, \textit{Testqualität} und \textit{Systemqualität} in eine Relation zueinander gestellt:
\begin{quotation}
	\textit{Während Unit-Tests dazu dienen, die korrekte
	Funktionsweise der erstellten Software zu verifizieren und die Qualität des Gesamtsystems zu steigern, dient die Analyse der Codeabdeckung dazu, die Qualität der Tests sicherzustellen und zu erhöhen(\cite{Wang2006})}.
\end{quotation}
Demzufolge hat die Codeabdeckungsanalyse einen unmittelbaren Einfluss auf die Qualität der Tests und einen indirekten auf die Qualität des Gesamtsystems.

Testabdeckung wird anhand der Abdeckung des Kontrollflußes gemessen, der durch einen Graph dargestellt werden kann (siehe...). 


 Die bekanntesten Abdeckungsmetriken werden im nächsten Abschnitt beschrieben.
\subsection{Abdeckungsmetriken }\label{Abdeckungsmetriken}
Es gibt eine Vielzahl von unterschiedlichsten Abdeckungsmetriken (\cite{Kaner1995}). In diesem Abschnitt werden nur die wichtigsten Abdeckungsmetriken vorgestellt, die für diese Arbeit relevant sind.

Als \textit{Testabdeckung} wird üblicherweise das Verhältnis zwischen
zu testenden und tatsächlich getesteten Elementen des Prüflings bezeichnet. Es muss nicht immer 100\% gefordert werden. Je nach festgelegtem Ziel kann auch ein gewisser Anteil festgelegt werden. Die bekanntesten Kriterien sind 
Anweisungs-, Zweig-, Bedingungs- und Pfadüberdeckung.
\subsubsection{Anweisungsabdeckung}
Die Anweisungsabdeckung (\textit{eng. statement coverage}) ist die enfachse kontrollflußorientierte Metrik.  
Sie wird wie folgt definiert: 
\[
	Anweisungsabdeckung=\frac{\text{\textit{Anzahl der ausgeführten Anweisungen}}}{\text{\textit{Anzahl der Anweisungen}}}
\]
Das Ziel der Anweisungsüberdeckung ist die mindestens einmalige Ausführung aller Anweisungen des zu testenden Programms.
Bezogen auf den Kontrollflußgraph heißt es, dass alle Knoten abgedeckt werden müssen. Es ist möglich, mehrerer Anweisungen (z. B. Anweisungen innerhalb einer Schleife) zu einer Einheit
zusammenzufassen, die keinerlei Verzweigungen im Sinne von \textit{if-else}-Anweisungen enthält. zusammenzufassen. Wenn die 100\% Anweisungsabdeckung nicht erreicht werden kann, dann ist das ein Hinweis auf Programmcode, der möglicherweise unter keinen Umständen ausgeführt werden kann. 

Anweisungsabdeckung ist ein schwaches Kriterium. Die Fehleridentifizierungsquote ist sehr niedrig und wird in der Literatur mit 18\% angegeben. Der Grund dafür ist, dass Anweisungsabdeckung nur die einzelnen Anweisungen betrachtet, ohne Zusammenhänge zu berücksichtigen.
\subsubsection{Zweigabdeckung}\label{Zweigabdeckung}
Zweigabdeckung (\textit{eng. branch coverage}) gilt als minimales Kriterium für kontrollflußorientierte Testtechniken.
\[
Zweigabdeckung=\frac{\text{\textit{\#(durchlaufene Zweige)+\#(Links(transitionCondition=true$|$false))}}}{\text{\textit{\#(alle Zweige) + 2*\#(Links)}}}
\]
Das heißt, dass die hundertprozentige Zweigabdeckung dann erreicht ist, wenn alle Kanten des Kontrollflussgraphen mindestens einmal durchlaufen wurden. Erfüllte Zweigabdeckung stellt sicher, dass alle Verzweigungen des zu testenden Moduls tatsächlich erreichbar sind. Weil das Durchlaufen aller Zweige die Ausführung aller Anweisungen verursacht, impliziert die Zweigabdeckung die Erfüllung der Anweisungsabdeckung. Mit der Zweigabdeckung können die nichtausführbaren Programmzweige zusätzlich aufgespürt werden. 

Obwohl die Fehlererkennungsquote gegenüber der Anweisungsabdeckung steigt, werden nicht alle Aspekte des Kontrollflusses erfasst. Bei den Schleifen wird nur ermittelt, ob diese durchlaufen werden können.
Obwohl bei der vollständigen Zweigabdeckung jede Entscheidung (komplexe Bedingungen), die Verzweigungen im Kontrollfluss auslösen, insgesamt die Wahrheitswerte $wahr$ und $falsch$ mindestens einmal annehmen muss, bleiben die Werte der einzelnen Bedingungen unberücksichtigt. Außerdem wird jeder Zweig für sich alleine betrachtet, ohne die Kombinationen von Zweigen zu berücksichtigen. 

Es gibt viele weitere Abdeckungsmaße, die in dieser Arbeit nicht betrachtet werden. Eine Übersicht der Metriken wird in ... gegeben

\nocite{Liggesmeyer2002}
\nocite{Winkler2003}