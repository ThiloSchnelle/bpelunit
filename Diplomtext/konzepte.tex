
In diesem Abschnitt werden einige Ansätze für die Messung der Testabdeckung in BPEL-Prozessen betrachtet und bewertet. Zum Schluss wird eine geeignete Lösung für die Integration in BPELUnit-Framework ausgewählt.  


Die Verfahren, die in konventionellen Sprachen für die Messung der Abdeckung verwendet werden, können nicht direkt auf BPEL übertragen werden. Es müssen einige BPEL-spezifische Restriktionen beachtet werden:
\begin{itemize}
\item BPEL-Prozesse werden in speziellen Ablaufumgebungen (\textit{BPEL-Engine}) ausgeführt.
\item BPEL-Prozesse können nur mit Web Services (\textit{partner}) kommunizieren.
\item Geschäftslogik wird in BPEL-Prozessen durch Aktivitäten realisiert. 
\end{itemize} 


Es gibt mehrere Möglichkeiten die Informationen über Ablauf eines BPEL-Prozesses zu sammeln: 
\begin{itemize} 
	\item \textbf{Instrumentierung}. Der Quellcode wird vor dem Deployen und Ausführen modifiziert, indem bestimmte Aktivitäten hinzugefügt werden, die die Ausführung der entsprechenden Codebereichen signalisiereb. 
	\item \textbf{Tracing}. Der Ablauf des Programms wird über eine Debug-API der Ablaufumgebung  mitverfolgt.
	\item \textbf{Web Service-Mock's}(\cite{Mayer2006}). Während der Ausführung können aufgerufene Mock-Partner (Web Services, die durch Mock's ersetzt wurden) ihre Interaktionen mit dem BPEL-Prozess protokollieren. 
	\item \textbf{Log-Dateien der BPEL-Ausführungsumgebung}(\cite{Li2005}). Aus den Log-Dateien der Ausführungsumgebung kann Information über den Ablauf des BPEL-Prozesses extrahiert werden. 
\end{itemize}

    
Da die dritte und vierte Möglichkeit sich für die Messung der Abdeckung nicht besonders gut eignen und daher keine wirkliche Alternative darstellen, werden sie an dieser Stelle nur ganz kurz behandelt. Durch eine Erweiterung der Logik von Web Service-Mock's ist es möglich, die Interaktionen der Mock's mit dem BPEL-Prozess zu protokollieren. Aus dise Weise lassen sich nur Auusagen über externes Verhalten des Prozesses (Kommunikation mit anderen Web Services) machen. Die interne Logik und der Kontrollfluss bleiben während der Laufzeit verborgen. Zur Ermittlung von Metriken fehlt damit die Information über die Ausführung des Prozesses. Die Log-Dateien der Ablaufumgebungen, wenn diese überhaupt existieren, sind anbieterabhängig und nicht standardisiert, was diese Möglichkeit auch ausschließt. 

Der Instrumentierungs- und Tracingansatz sind als Verfahren für die Messung der Codeabdeckung aus dem Bereich der konventionellen Programmiersprachen bekannt. Die beiden Ansätze wurden in der Masterarbeit von P.Dul \cite{Dul2005} im Bezug auf Programmiersprache Java detailliert untersucht und verglichen.
 
\section{Instrumentierungsansatz.}

Weirverbreitet Cobertura für Java

\begin{wrapfigure}[14]{r}{6cm}
\centering%
\includegraphics[width=0.3\textwidth]{bilder/Instrumentierung.png}%
\label{}
\end{wrapfigure}
Bei der Instrumentierung handelt es sich um ein einfaches Verfahren zur Messung der Testabdeckung, das von vielen Werkzeugen eingesetzt wird. Dabei werden in den Quellcode zusätzliche Anweisungen eingefügt, die die Ausführung bestimmter Codebereiche dokumentieren. Damit der Originalcode unverändert bleibt, wird die Instrumentierung auf einer Kopie durchgeführt. 

Während der Instrumentierung werden die relevanten statistischen Daten des Quellcodes, die für die Auswertung der Ergebnisse notwendig sind, gesammelt und gespeichert. Anhand dieser Daten und der Information, die während der Ausführung gesammelt wird, kann die Auswertung erfolgen und die Codeabdeckung ermittelt werden. Der Instrumentierungsansatz führt zu einer erheblichen Vergrößerung des Programms.  

Es existieren zahlreiche kommerzielle und nicht-kommerzielle Werkzeuge zur Messung der Testabdeckung. Für Java Cobertura unter General Public License stehnde... Instrumentierung findet auf der Java Bytecode-Ebene statt.

Eine dynamische Analyse hat jeder schon verwendet: Testen. Auch dabei wird das Programm ausgef¨uhrt, das
Verhalten des Programms w¨ahrend der Ausf¨uhrung beobachtet und aus den Beobachtungen R¨uckschl¨usse gezogen
(ist die Spezifikation erf¨ullt oder nicht?).
Auch beim Testen ist die Wahl der Testf¨alle entscheidend: M¨oglichst alle Teile des Programms sollen in allen
Varianten mindestens einmal ausgef¨uhrt worden sein. Eine hohe Testabdeckung ist also w¨unschenswert. Genauso ist
es bei den meisten dynamischen Analysen.
F¨ur weitergehende Analysen ist in der Regel ein Blick in den inneren Zustand des Programms notwendig. Daher
m¨ussen Vorkehrungen getroffen werden, um diesen Zustand zugreifbar zu machen. Zum Beispiel m¨ussen evtl.
Variablenwerte ausgegeben oder das Passieren bestimmter Punkte erfasst werden. Dazu ist eine Instrumentierung
notwendig.

Clover

Mit dem Clover Plugin für Eclipse ist es möglich, innerhalb der IDE Java-Projekte zu kompilieren, mit JUnit zu testen und den Grad der Testabdeckung der Unit-Tests sofort in einer separaten View zu sichten, ohne dabei die Entwicklungsumgebung zu verlassen. Das kommerzielle Tool ist eines der ältesten Vertreter aus dem Bereich Code Coverage. Der Name "Clover" ist übrigens die Kurzform des Kosenamens des Autors "Mr. Clover Lover" und bedeutet übersetzt "Kleeblatt".
Code Coverage

Unter dem Begriff Code Coverage versteht man die Messung des von Unit-Tests abgedeckten Source Code. Noch nicht getestete Programmzeilen lassen sich dadurch schnell aufspüren.

Beim Code Coverage gibt es unterschiedliche Coverage Metriken, wie zum Beispiel Branch-, Decision-, Line- oder Path-Coverage. Die verschiedenen Ansätze sollen hier aber im Einzelnen nicht näher betrachtet werden. Festzuhalten ist nur, dass es verschiedene Herangehensweisen und Messmethoden gibt, um das Verhältnis von getestetem Quellcode zum gesamten Projekt zu errechnen und (grafisch) darzustellen.   

\section{Tracingansatz}
Die modernen Entwicklungsumgebungen verfügen über Debugger, die unter anderem eine Tracing-Funktionalität mit sich mitbringen.
\begin{quotation}
	\textit{Tracing bezeichnet man in der Programmierung eine Funktion zur Analyse von Fehlersuche von Programmen.
Dabei wird z.B. bei jedem Einsprung in eine Funktion, sowie bei jedem Verlassen eine Meldung ausgegeben, sodass der Programmierer mitverfolgen kann, wann und von wo welche Funktion aufgerufen wird...Wikipedia}
\end{quotation}
Diese Funktionalität erlaubt den Ablauf des Programms zu verfolgen und kann zur Messung der Testabdeckung genutzt werden. Auch bei diesem Ansatz wird der Quellcode im Vorfeld analysiert, um alle relevanten statischen Informationen zu sammeln. 

\section{Vergleich der Verfahren und Auswahl des Ansatzes für die Realisierung der Abdeckungsmessung in BPEL}
Die Tabelle \ref{Vergleichstabelle} beruht auf Ergebnissen aus \cite{Dul2005} und stellt die beiden Verfahren im BPEL-Context gegenüber.
\begin{table}[h!]
\begin{tabular}{p{6cm}p{0.5cm}p{6cm}}
\textbf{Instrumentierungsansatz}&\ &\textbf{Tracingansatz}\\[0.1cm]
\hline \\
Basiert auf dem Hinzufügen von
Instrumentierungsanweisungen in
eine Kopie des zu untersuchenden
Quellcodes.&\ &
 Basiert auf den Fähigkeiten des
Debuggers, Informationen
über das ablaufende
Programm zu erhalten.\\
\\
 Es besteht grundsätzlich die
Gefahr den Programmablauf oder
die Programmlogik durch das
Hinzufügen von Instrumentierungsanweisungen zu
verändern.&\ &
 Es besteht keine Gefahr, dass der
Programmablauf oder die Programmlogik
beim Tracingansatz
verändert werden.\\
\\
 Es besteht grundsätzlich die
Gefahr von Namenskonflikten
oder der Verletzung der Spezifikation.&\ &
 Es besteht keine Gefahr, dass
Namenskonflikte oder eine
Verletzung der Spezifikation
auftreten.\\
\\
 Overhead wird durch zusätzliche
Aktivitäten im Quellcode
generiert.&\ &
 Overhead wird durch die
Anwendung der Debug-API generiert.\\
\\
 Es ist eine aktivitätsbasierte
Messung der Testabdeckung
möglich.&\ &
 Es ist nur eine zeilenbasierte
Messung der Testabdeckung
möglich.\\
\\
Die Messung bleibt unabhängig von 
Anbieter der Ablaufumgebung.&\ & 
Die Messung ist nur möglich, wenn der Anbieter der Ablaufumgebung eine Tracing-Funktion unterstützt. Die Lösung ist anbieterspezifisch.
\end{tabular}
\caption{Vergleich der Ansätze\cite{Dul2005}}
\label{Vergleichstabelle}
\end{table}

Zahlenmäßig weist der Tracingansatz weniger Nachteile auf. Jedoch fehlt es teilweise Unterstützung der BPEL-Ablaufumgebungen für Debugging bzw. es gibt keine Tracing-Funktionalität, die die Verfolgung des Ablaufs ermöglichen würde. Noch größeres Problem ist, dass diese Schnittstelle in keinster Weise standardisiert ist. Alle Nachteile des Instrumentierungsansatzes entstehen aus der Tatsache, dass die Manipulation des Quellcodes stattfindet. 

Bei der Fallstudie in der oben erwähnten Masterarbeit wurde festgestellt, dass die Messung beim Tracingansatz wesentlich langsamer ist, als beim Instrumentierungsansatz. Diese Aussage hat aber für den BPEL-Prozess, der die Dienste über Netzwerk anspricht, keine Gültigkeit. Der Grund dafür ist der Netzwerkzugriff, der für die Kommunikation notwendig ist. Auch wenn BPELUnit-Framework die Möglichkeit anbietet, den BPEL-Prozess isoliert von den einzelnen Web Servives zu testen, werden die Mock's, die Web Services simulieren, immer noch über Netzwerkschicht angesprochen. Die Programmeinheit, die die Meldungen über Ausführung bestimmter Codeteile empfängt, muss ebenfalls über Netzwerkschicht angesprochen werden. Außerdem muss die Zeit für die Instrumentierung berücksichtigt werden. Im Kapitel \ref{chap:fallstudie} werden für die vorgestellten Beispiele gemessene Zeitdifferenzen angegeben. 


\textbf{Auswahl des Ansatzes für die Realisierung der Abdeckungsmessung in BPEL}\ \\
Da nur die ersten beiden Ansätze (Instrumentierungs- und Tracingansatz) die Realisierung der Abdeckungsmessung für alle definierten Abdeckungsmetriken (siehe Abschnitt \ref{metrikdefinition}) im nötigen Umfang ermöglichen, reduziert sich die Auswahl auf diese Beiden.

Aufgrund der vorgesehenen Integration der Lösung in das BPELUnit Framework muss bei der Auswahl des Verfahrens auf die Kompatibilität zum Framework und den darunterliegenden Konzepten geachtet werden.  Eine der zentralen Ziele bei der Konzeption des BPELUnit Frameworks war die Anbieterunabhängigkeit. In dieser Hinsicht hat man sich entschieden, den Ansatz \textit{real-life Testen} zu verwenden und damit auf die Verwendung von Debug-API zu verzichten. Das Deployment ist zwar immer noch anbieterspezifisch, die Abhängigkeit wurde aber mit dieser Entscheidung auf einen Minimum reduziert. 
Der Einsatz der Tracing-Funktionalität für die Messung der Testabdeckung würde  die Verwendung des Frameworks mit BPEL-Ablaufumgebungen ausschließen, die keine Traicing-Funktionalität unterstützen. Außerdem müsste das Framework an jede einzelne \textit{Engine} angepasst werden. Demzufolge eignet sich für die Messung der Abdeckung im BPELUnit Framework der Instrumentierungsansatz am Besten. 
