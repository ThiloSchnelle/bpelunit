
In diesem Abschnitt werden einige Ansätze für die Messung der Testabdeckung in BPEL-Prozessen betrachtet und bewertet. Zum Schluss wird eine geeignete Lösung für die Integration in BPELUnit-Framework ausgewählt.  


Die Verfahren, die in konventionellen Sprachen für die Messung der Abdeckung verwendet werden, können nicht direkt auf BPEL übertragen werden. Es müssen einige BPEL-spezifische Restriktionen beachtet werden:
\begin{itemize}
\item BPEL-Prozesse werden in speziellen Ablaufumgebungen (\textit{BPEL-Engine}) ausgeführt.
\item BPEL-Prozesse können nur mit Web Services (\textit{Partner}) kommunizieren.
\item Geschäftslogik wird in BPEL-Prozessen durch Aktivitäten realisiert. 
\end{itemize} 


Es gibt mehrere Möglichkeiten die Informationen über Ablauf eines BPEL-Prozesses zu sammeln: 
\begin{itemize} 
	\item \textbf{Instrumentierung}. Der Quellcode wird vor dem Deployen und Ausführen modifiziert, indem bestimmte Aktivitäten hinzugefügt werden, die die Ausführung der entsprechenden Codebereichen signalisieren. 
	\item \textbf{Tracing}. Der Ablauf des Programms wird über eine Debug-API der Ablaufumgebung  mitverfolgt.
	\item \textbf{Web Service-Mock's}\cite{Mayer2006}. Während der Ausführung können aufgerufene Mock-Partner (Web Services, die durch Mock's ersetzt wurden) ihre Interaktionen mit dem BPEL-Prozess protokollieren. 
	\item \textbf{Log-Dateien der BPEL-Ausführungsumgebung}\cite{Li2005}. Aus den Log-Dateien der BPEL-Engines kann Information über den Ablauf des BPEL-Prozesses extrahiert werden. 
\end{itemize}

    
Die dritte und vierte Möglichkeit eignen sich für die Messung der Abdeckung nicht und werden daher an dieser Stelle nur kurz behandelt. Durch eine Erweiterung der Logik von Web Service-Mock's ist es möglich, die Interaktionen der Mock's mit dem BPEL-Prozess zu protokollieren. Auf diese Weise lassen sich nur Aussagen über externes Verhalten des Prozesses (Kommunikation mit anderen Web Services) machen. Die interne Logik und der Kontrollfluss bleiben während der Laufzeit verborgen. Zur Ermittlung von Metriken fehlen damit die Informationen über die Ausführung des Prozesses. Die Log-Dateien der Ablaufumgebungen, wenn diese überhaupt existieren, sind anbieterabhängig und nicht standardisiert, was diese Möglichkeit ebenfalls ausschließt. 

Der Instrumentierungs- und Tracingansatz sind als Verfahren für die Messung der Codeabdeckung aus dem Bereich der konventionellen Programmiersprachen bekannt. Die beiden Ansätze wurden in der Masterarbeit von P.Dul \cite{Dul2005} im Bezug auf Programmiersprache Java detailliert untersucht und verglichen.
 
\section{Instrumentierungsansatz.}

\begin{wrapfigure}[14]{r}{6cm}
\centering%
\includegraphics[width=0.3\textwidth]{bilder/Instrumentierung.png}%
\label{}
\end{wrapfigure}
Bei der Instrumentierung handelt es sich um ein einfaches Verfahren zur Messung der Testabdeckung, das in zahlreichen kommerziellen und nicht kommerziellen Werkzeugen eingesetzt wird. Cobertura ist ein bekanntes Werkzeug zur Ermittlung der Testabdeckung in Java-Programmen, das unter General Public License verfügbar ist und auf dem Instrumentierungsverfahren basiert. 

Bei der Instrumentierung werden in den Quellcode zusätzliche Anweisungen eingefügt, die die Ausführung bestimmter Codebereiche dokumentieren. Die Instrumentierung kann manuell oder durch ein Werkzeug erfolgen und wird auf einer Kopie durchgeführt, um Originalcode zu schützen.

Während der Instrumentierung werden die relevanten statistischen Daten des Quellcodes, die für die Auswertung der Ergebnisse notwendig sind, gesammelt und gespeichert. Anhand dieser Daten und der Information, die während der Ausführung gesammelt wird, kann die Auswertung erfolgen und die Codeabdeckung ermittelt werden. Der Instrumentierungsansatz führt offensichtlich zu einer erheblichen Zunahme der
Programmgröße: Es wird eine Kopie des originalen Quellcodes generiert und diese anschließend mit weiteren Anweisungen erweitert.

\section{Tracingansatz}
Die modernen Entwicklungsumgebungen verfügen über Debugger, die unter anderem eine Tracing-Funktionalität mit sich mitbringen.
\begin{quotation}
	\textit{Tracing bezeichnet man in der Programmierung eine Funktion zur Analyse von Fehlersuche von Programmen.
Dabei wird z.B. bei jedem Einsprung in eine Funktion, sowie bei jedem Verlassen eine Meldung ausgegeben, sodass der Programmierer mitverfolgen kann, wann und von wo welche Funktion aufgerufen wird...Wikipedia}
\end{quotation}
Mit dieser Funktionalität kann der Ablauf des Programms verfolgt werden: Methodenaufrufe und Ausführung der einzelnen Anweisungen in den konventionellen Programmiersprachen und Aktivitäten in BPEL. Die Messung der Testabdeckung kann mit dem Tracingansatz realisierbar. Die Sammlung aller statistischen Informationen findet auch in diesem Fall im Vorfeld.

\section{Vergleich der Verfahren und Auswahl des Ansatzes für die Realisierung der Abdeckungsmessung in BPEL}
Die Tabelle \ref{Vergleichstabelle} beruht auf Ergebnissen aus der Masterarbeit \cite{Dul2005} und stellt die beiden Verfahren im BPEL-Kontext gegenüber.
\begin{table}[h!]
\centering
\begin{tabular}{p{6cm}p{0.5cm}p{6cm}}
\textbf{Instrumentierungsansatz}&\ &\textbf{Tracingansatz}\\[0.1cm]
\hline \\
Basiert auf dem Hinzufügen von
Instrumentierungsanweisungen in
eine Kopie des zu untersuchenden
Quellcodes.&\ &
 Basiert auf den Fähigkeiten des
Debuggers, Informationen
über das ablaufende
Programm zu erhalten.\\
\\
 Es besteht grundsätzlich die
Gefahr den Programmablauf oder
die Programmlogik durch das
Hinzufügen von Instrumentierungsanweisungen zu
verändern.&\ &
 Es besteht keine Gefahr, dass der
Programmablauf oder die Programmlogik
beim Tracingansatz
verändert werden.\\
\\
 Es besteht grundsätzlich die
Gefahr von Namenskonflikten
oder der Verletzung der Spezifikation.&\ &
 Es besteht keine Gefahr, dass
Namenskonflikte oder eine
Verletzung der Spezifikation
auftreten.\\
\\
 Overhead wird durch zusätzliche
Aktivitäten im Quellcode
generiert.&\ &
 Overhead wird durch die
Anwendung der Debug-API generiert.\\
\\
 Es ist eine aktivitätsbasierte
Messung der Testabdeckung
möglich.&\ &
 Es ist nur eine zeilenbasierte
Messung der Testabdeckung
möglich.\\
\\
Die Messung bleibt unabhängig von 
Anbieter der Ablaufumgebung.&\ & 
Die Messung ist nur möglich, wenn der Anbieter der Ablaufumgebung eine Tracing-Funktion unterstützt. Die Lösung ist anbieterspezifisch.
\end{tabular}
\caption{Vergleich der Ansätze\cite{Dul2005}}
\label{Vergleichstabelle}
\end{table}

Zahlenmäßig weist der Tracingansatz weniger Nachteile auf. Jedoch fehlt es teilweise Unterstützung der BPEL-Ablaufumgebungen für Debugging bzw. es gibt keine Tracing-Funktiona\-lität, die die Verfolgung des Ablaufs ermöglichen würde. Noch größeres Problem ist, dass diese Schnittstelle in keinster Weise standardisiert ist. Alle Nachteile des Instrumentierungsansatzes entstehen aus der Tatsache, dass die Manipulation des Quellcodes stattfindet. 

Bei der Fallstudie in der oben erwähnten Masterarbeit wurde festgestellt, dass die Messung beim Tracingansatz wesentlich langsamer ist, als beim Instrumentierungsansatz. Diese Aussage hat aber für den BPEL-Prozess, der die Dienste über Netzwerk anspricht, keine Gültigkeit. Der Grund dafür ist der Netzwerkzugriff, der für die Kommunikation notwendig ist. Auch wenn BPELUnit-Framework die Möglichkeit anbietet, den BPEL-Prozess isoliert von den einzelnen Web Servives zu testen, werden die Mock's, die Web Services simulieren, immer noch über Netzwerkschicht angesprochen. Die Programmeinheit, die die Meldungen über Ausführung bestimmter Codeteile empfängt, muss ebenfalls über Netzwerkschicht angesprochen werden. Außerdem muss die Zeit für die Instrumentierung berücksichtigt werden. Es ist zu erwarten, dass die Abdeckungsmessung in den BPEL-Kompositionen bei diesem Verfahren einen erheblichen Zeitoverhead verursachen wird.  Im Kapitel \ref{chap:fallstudie} werden für die vorgestellten Beispiele gemessene Zeitdifferenzen angegeben. 


\textbf{Auswahl des Ansatzes für die Realisierung der Abdeckungsmessung in BPEL}\ \\
Da nur die ersten beiden Ansätze (Instrumentierungs- und Tracingansatz) die Realisierung der Abdeckungsmessung für alle im Abschnitt \ref{sec:metrikdefinition} definierten Abdeckungsmetriken im nötigen Umfang ermöglichen, reduziert sich die Auswahl auf diese Beiden.

Aufgrund der vorgesehenen Integration der Lösung in das BPELUnit-Framework muss bei der Auswahl des Verfahrens auf die Kompatibilität zum Framework und den darunter liegenden Konzepten geachtet werden.  Eine der zentralen Ziele bei der Konzeption des BPELUnit-Frameworks war die Anbieterunabhängigkeit. In dieser Hinsicht hat man sich entschieden, den Ansatz \textit{real-life Testen} (Abschnitt \ref{sec:framework}) zu verwenden und damit auf die Verwendung von Debug-API zu verzichten. Das \textit{Deployment} ist zwar immer noch anbieterspezifisch, die Abhängigkeit wurde aber mit dieser Entscheidung auf einen Minimum reduziert. 
Der Einsatz der Tracing-Funktionalität für die Messung der Testabdeckung würde  die Verwendung des Frameworks mit BPEL-Engines ausschließen, die keine Traicing-Funktionalität unterstützen. Außerdem müsste die Verfahren zur Testabdeckungsmessung an jede einzelne \textit{Engine} angepasst werden. Demzufolge eignet sich für die Messung der Abdeckung im BPELUnit-Framework der Instrumentierungsansatz am Besten. 
