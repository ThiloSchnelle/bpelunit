BPEL ist eine XML-basierte, ausführbare Sprache zur Modellierung und Beschreibung
von Geschäftsprozessen. BPEL ist 2002 aus IBMs WSFL und Microsofts XLANG entstanden und liegt aktuell in der Version 2.0  als OASIS Standard vor. Durch breite Produktunterstützung ist die Sprache auf dem Weg, sich auch als Industriestandard zu etabliert.


Mit BPEL lässt sich ein Prozess beschreiben, der verschiedene Dienste zu einer Gesamtanwendung verknüpft. Web Services können auf zwei Arten kombiniert werden:
\begin{itemize}
	\item \textbf{Orchestration:} Ein zentraler Prozess koordiniert die
Operationen der Web Services, die in den Prozess
eingebunden sind.
\item \textbf{Choreography:} Es gibt keinen zentralen Koordinator. Jeder in
die Choreography eingebundene Web Service kenn seine Interaktionspartner. Bei der Choreographie erfolgt
die Zusammenarbeit über den Austausch von Nachrichten
in einem öffentlichen Prozess.
\end{itemize}

BPEL unterstützt Orchestration und Choreography durch
\begin{itemize}
	\item \textbf{Executable Processes:} Spezifikation des intenen Verahaltens eines
Ge\-schäfts\-pro\-zesses, der durch eine Engine
ausgeführt werden kann. Enthält alle für die Pro\-zess\-aus\-füh\-rung notwendige Informationen bis auf die tatsächlichen Endpunkte der Web Services.
\item \textbf{Abstract Business Processes:} Spezifikation des
Nachrichtenaustauschs zwischen Partnern. Beschreibung des nach außen sichbaren Verhaltens des Prozesses. Keine Aussagen über interne Logik.
\end{itemize}

Während abstrakte Prozesse nur der Beschreibung des Prozessverhaltens dienen,  können ausführbare BPEL-Prozesse, wie der Name schon sagt, in einer BPEL-Engine ausgeführt werden. Da der Kontext dieser Arbeit das Testen von BPEL-Prozessen ist, und das Testen die Ausführung voraussetzt, sind dementsprechend auch nur die ausführbaren Prozesse relevant. Die weiteren Betrachtungen in dieser Arbeit beschränken sich aus diesem Grund ausschließlich auf die \textit{Ausführbaren Prozesse}.


Mit BPEL können langlebige und zustandsbehaftete Prozesse modelliert werden. Es ist dabei möglich, eine sehr flexible Fehlerbehandlung mit Kompensationsmöglichkeiten zu realisieren. Durch die strikte Trennung der Geschäftslogik (BPEL-Prozess) und Implementierung (einzelnen Web Services) ist die Anpassung bei Änderungen des zugehörigen Geschäftsprozesses einfach durchzuführen. Bei ausreichend kleiner Granularität der einzelnen Services betreffen die Auswirkungen einer Änderung ausschließlich den BPEL-Prozess selbst.

Die Schnittstelle nach außen eines BPEL-Prozesses wird ebenfalls in WSDL beschrieben und kann wiederum als Web Service in andere Prozesse eingebunden werden.
Die damit gegebene Rekursivität ermöglicht durch hierarchische Aufbau der Prozessen die Abstraktionsschichten einzuführen und damit die Komplexität besser zu beherrschen.

Allerdings bring BPEL auch einige Nachteile mit sich. Als Erstes ist die Komplexität der Sprache zu nennen. Jedoch ist diese Komplexität in dem Anspruch begründet, jede Art von Geschäftsprozessen realisieren zu können und zwar quer zu allen IT-Plattformen. Auch zu nennen sind die redundanten Ausdrucksmittel der Sprache, die aufgrund der Vereinigung zwei Sprachen entstanden sind, und oft das Verständnis der Prozessen erschweren. Als letztes ist noch das Fehlen einer standardisierten grafischen Notation zu erwähnen.

In den folgenden Abschnitten wird auf einige für diese Arbeit relevanten Aspekte der BPEL eingegangen.

\subsection{Partners}

BPEL-Prozesse interagieren mit anderen Web Services, die
man als Partner oder Partner-Prozesse bezeichnet. Ein
BPEL-Prozess benutzt Dienste von Partnern und bietet selbst Dienste nach außen an. Die Beziehung zwischen den möglichen Partner und dem Prozess selbst wird zuerst abstrakt durch die Rollen in einem \textit{Partner Link Type} beschrieben. In jedem solchen Element werden mindestens eine und maximal zwei Rollen definiert. Die Rollen können dabei entweder vom Prozess oder vom Partner übernommen werden.  Derjenige der diese Rolle übernimmt muss den \textit{Port Type}, der zu der Rolle zugeordnet ist, in seiner WSDL-Schnittstelle anbieten.

Die Beziehung zwischen dem BPEL-Prozess und einem konkreten Partner wird letztendlich in \textit{Partner Link} durch die Zuweisung der Rollen definiert.
Die Bindung an einen konkreten Web Service kann entweder statisch zum Zeitpunkt des Deployments oder dynamisch zur Laufzeit erfolgen. Die Abbildung \ref{fig:partnerLink} stellt den ganzen Zusammenhang grafisch dar.
\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.8\textwidth]{bilder/partnerLink.png}
		\caption{Partner Link\cite{Dieter}}
	\label{fig:partnerLink}
\end{figure}

\subsection{BPEL Prozess}
BPEL-Prozess ist definiert in Form eines XML-Dokuments. Die Wurzel eines BPEL-Dokuments ist das Element $<$process$>$, welches die Struktur und den
Kontrollfluss eines Geschäftsprozesses in sich kapselt. Das Prozess-Element enthält drei wichtige Abschnitte:

\begin{itemize}
	\item \textit{Partner Links} - Partner Link-Definitionen, die für Kommunikation mit den Partner benutzt werden.   
	\item \textit{Variables} -  Variablen für die Speicherung von internen Daten und Daten, die Empfangen oder Gesendet werden.  Alle in diesem Bereich definierten Variablen sind globale Variablen. Es gibt Möglichkeit lokale Variablen zu definieren. Sie werden in einem Sichtbarkeitsbereich
(Scope) durch einen eindeutigen Namen und einen Datentyp definiert. 
	\item \textit{Activity} - Geschäftslogik in Form von Aktivitäten. 
\end{itemize}
 
Die Geschäftslogik wird in BPEL durch so genannte Aktivitäten realisiert. Es gibt zwei Arten von Aktivitäten: Basisaktivitäten (basic activities) und Strukturierte Aktivitäten (structured activities). Basisaktivitäten beschreiben die elementaren Schritte des Prozesses. Strukturierten Aktivitäten bestimmen den Kontrollfluss und können deswegen weitere Basis- oder Strukturierten Aktivitäten enthalten. 

Die Basisaktivitäten sind: 
\begin{itemize}
\item $<$invoke$>$ - Aufruf anderer Web Services aus dem Prozess heraus. 
\item $<$receive$>$ - Blockierendes Warten auf Nachrichten.
\item $<$reply$>$ - Versenden einer Antwort.
\item $<$assign$>$ - Zuweisung und Manipulation von Variablenwerten.
\item $<$throw$>$ - Explizites Signalisieren eines Fehlers, welcher durch Fehlerbehandlungen abgefangen werden kann.
\item $<$exit$>$ - Beenden einer Prozessinstanz.
\item $<$wait$>$ - Warten auf einen Zeitpunkt oder für eine Zeitspanne.
\item $<$empty$>$ - Nichts machen (NOP).
\item $<$compensate$>$ - Kompensation aller eingebetteten Scopes, $<$compensate$>$ kann nur im FaultHandler
oder CompensationHandler eingebettet sein.
\item $<$compensateScope$>$ - Kompensation
eines speziellen Scope.
\item $<$rethrow$>$ - Wieterreichen der abgefangenen Fehler.
\item $<$validate$>$ - Validierung der Variablenwerten gegen XML-Schema.
	\end{itemize}
Mit den ersten drei lassen sich alle Kommunikationsszenarien implementieren:
\begin{itemize}
	\item synchrone request\slash response-Kommunikation
	\item asynchrone request\slash response-Kommunikation
	\item \textit{one way}-Kommunikation
\end{itemize}

WS-BPEL beschreibt den Ablauf von Geschäftsprozessen als strukturierte Aktivitäten:
\begin{itemize}
\item $<$sequence$>$ - sequentielle Ausführung von Aktivitäten
\item $<$if$>$ - bedingte Auführung von Aktivitäten.\textit{ if}-Aktivität besitzt mehrere geordnete Bedingte Zweige definiert  durch $<$\textit{if}$>$- und $<$\textit{elseif}$>$- Elemente gefolgt von einem optionalem $<$\textit{else}$>$-Element. Der erste Zweig mit der zutreffenden Bedingung wird ausgeführt. 
\item $<$while$>$ - iterative Ausführung der Aktivitäten. Die Ausführung findet solange statt, bis die Bedingung nicht mehr erfüllt ist. Die Auswertung der Bedingung findet vor jeder Schleifenausführung statt.
\item $<$repeatUntil$>$ - iterative Ausführung von Aktivitäten. Die Ausführung findet solange statt, bis die Bedingung erfüllt ist. Die Auswertung der Bedingung findet nach jeder Schleifenausführung statt.
\item $<$forEach$>$ -  iterative Ausführung von Aktivitäten. Die Ausführung kann entweder seriell oder parallel erfolgen (gesteuert durch Attribut \textit{parallel}).
\item $<$pick$>$ - blockierendes Warten auf  Eintreffen eines von mehreren Ereignissen. Bei dieser strukturierenden Aktivität wird ein Zweig aus mehreren anhand eines Ereignisses (Nachricht oder Alarm) ausgewählt. Wurde ein zutreffendes Ereignis empfangen, so wird die zugehörige Aktivität ausgeführt und alle nachfolgenden Ereignisse verworfen. 
\item $<$flow$>$ - ermöglicht parallele Ausführung von Aktivitäten mit Synchronisationsmöglichkeit (siehe Abschnitt \ref{sec:linkkonzept}).  
\end{itemize}



\subsection{Link-Konzept}\label{sec:linkkonzept}
 In einer flow-Aktivität können Links definiert werden. Sie dienen
der Synchronisation nebenläufiger Aktivitäten. Jeder Link verbindet eine
\textit{source}-  mit einer \textit{target}-Aktivität.
Jeder Link hat eine implizite oder explizite \textit{transition condition} (boolscher Ausdruck). Ist der Ausdruck nicht spezifiziert, so ist der Wert der \textit{transition condition} \textit{true}. Jede Aktivität, die das Ziel eines Links ist, hat eine implizite oder explizite \textit{join condition} (boolscher Ausdruck). Im impiziten Fall ist das eine ODER-Verknüpfung der Status aller eingehenden Links. Die Auswertung dieser Bedingungen bei der Ausführung wird an einem kleinem Beispiel erläutert.

\begin{figure}[h!]
	\centering
		\includegraphics[width=0.5\textwidth]{bilder/FlowBespielLinks.png}
	\caption{}
	\label{}
\end{figure}

Ist die Ausführung der Aktivität\_2 beendet, so wird \textit{transition condition} des Links ausgewertet und der Status auf den entsprechenden Wert \textit{true} oder \textit{false}  gesetzt. Auf dieselbe Weise wird der Status des zweiten Links ermittelt. Sind die Status der beiden Links ermittelt, so kann die \textit{join condition} der Aktivität\_ 3 ausgewertet werden. Bei einem \textit{true}-Wert wird die Ausführung des Prozesses mit der Aktivität\_3 ganz normal fortgesetzt. Ist der Wert \textit{false}, so wird eine Fehlermeldung (\textit{Join Failure}) erzeugt und der Kontrollfluss für Fehlerbehandlung aktiviert. Ist dieses Verhalten unerwünscht, so kann das Standardattribut \textit{suppressJoinFailure} auf den Wert \textit{"`yes"'} gesetzt. In diesem Fall wird Aktivität\_3 ebenfalls nicht ausgeführt, allerdings wird der Prozess ganz normal, ohne eine Fehelermeldung zu produzieren, mit der Aktivität\_4 fortgesetzt.

Ist die Aktivität\_2 zum Beispiel in einem \textit{if}-Zweig, der während der Ausführung nicht aktiviert wird, so kann der Status des ausgehenden Links nicht auf die normale Weise ermittelt werden. Die \textit{join condition} ohne des Status des zweiten Links kann nicht ausgewertet werden.  Das würde zu einer Blockierung des Kontrollflusses bei Aktivität\_3 führen. Für solche Situationen sieht BPEL \textit{Dead-Path-Elimination} vor. Wird eine Aktivität aufgrund einer zu
\textit{false} ausgewerteten \textit{join condition}
oder eines nicht abgearbeiteten Zweiges einer if- oder pick-Aktivität nicht
ausgeführt, so wird für alle eventuell vorhandenen ausgehenden Links die \textit{transition condition}
auf \textit{false} gesetzt. Diese Werte werden soweit wie möglich entlang des Pfades propagiert. Auf die Weise werden Pfade eliminiert, die nicht zur Ausführung kommen, und damit Blockierungen des Kontrollflusses vermieden.

Bei der Verwendung von Links ist folgendes zu beachten:
\begin{itemize}
	\item ein Link darf genau eine \textit{source} und eine \textit{target}-Aktivität verbinden,
	\item Links dürfen keine Zyklen bilden,
	\item es müssen \textit{boundary crossing}-Restriktionen beachtet werden:
\begin{itemize}
	\item Links dürfen nicht in oder aus den Wiederholungsschleifen und \textit{Compensation Handler} ein- bzw. austreten
	\item Links dürfen aus den \textit{Fault} und \textit{Termination Handler} nur austreten
	\item Links, die aus den \textit{catch} oder \textit{catchAll}-Blöcken des Fault Handlers oder aus dem Termination Handler austreten, müssen in einem nicht zu den Handlern zugehörigem \textit{Scope} landen.)
\end{itemize}
\end{itemize}

\subsection{\textit{Scope}}
\textit{Scopes} dienen zur Strukturierung von BPEL-Prozessen und definieren Sichtbarkeitsbereiche für Variablen und Ereignisse. Ein \textit{Scope} ist ein Ausfuhrungskontext für Aktivitäten mit der Möglichkeit,  eigene Fault, Compensation, Termination und Event Handler zu definieren.
\subsubsection{\textit{Event Handler}}
 BPEL bietet die Möglichkeit, parallel zum normalen Kontrollfluss bestimmte Ereignisse
mit so genannten \textit{Event Handlern} zu behandeln. \textit{Event Handler} gehören zu einem
bestimmten \textit{Scope} innerhalb des Prozesses oder zu dem globalen Prozess \textit{Scope}.
Sie behandeln Ereignisse, die den zugeordneten Gültigkeitsbereich betreffen.
Innerhalb eines \textit{Event Handlers} können beliebige Abfolgen von BPEL Aktivitäten definiert
werden. Es können zwei Typen von Ereignissen behandelt werden: Nachrichten und zeit gesteuerten Ereignisse.

\subsubsection{Fehlerbehandlung und Kompensation}
  BPEL-Sprache hat wie viele moderne Programmiersprachen ein Konzept zur strukturierten Behandlung von Laufzeitfehlern.
  Tritt ein Fehler im laufenden Prozess auf, so wird ein für diesen Bereich zuständiger \textit{Fault Handler} aufgerufen. 
  Oft müssen im Fehlerfall bereits abgeschlossene Aktivitäten kompensiert werden. In BPEL kann
dafür ein \textit{Compensation Handler} definiert werden, in dem Aktivitäten für die Kompensation festgelegt werden.
\textit{Compensation Handler} können nur aus \textit{Fault Handler} oder \textit{Compensation Handler} des umschließenden \textit{Scopes} aufgerufen werden. Außerdem ein \textit{Compensation Handler} kann nur für \textit{Scopes} aufgerufen werden, die
ordnungsgemäß abgearbeitet wurden. Jedes \textit{Scope} besitz ein Fault und \textit{Compensation Handler}, der Prozess selbst hat in BPEL 2.0 nur den \textit{Fault Handler}. 
  
Ist kein benutzerdefiniertes \textit{Fault Handler} spezifiziert, so gibt es ein impliziter \textit{Fault Handler}, der die \textit{Compensation Handler}
aller direkt eingeschlossener \textit{Scopes} in der umgekehrten Reihenfolge ihrer Abarbeitung aufruft und
anschließend den Fehler an den umschließenden Scope oder den Prozess selbst weiter reicht. Es können eigene \textit{Fault Handler} spezifiziert werden, der
je nach Art des auftretenden Fehlers eine bestimmte BPEL-Aktivität ausführt. Für die Bindung bestimmter Aktivitäten an die bestimmten Fehler werden \textit{catch} und \textit{catchAll}-Elemente verwendet.
  
Die Fehler können auch in den \textit{Compensation} und in den \textit{Fault Handler} selbst auftreten. In die Abbildung \ref{fig:ScopeFaultCompensation2} wird der Zusammenhang zwischen \textit{Handler} und \textit{Scopes} graphisch dargestellt. Die Pfeile zeigen dabei den möglichen Kontrollfluss. 
\begin{figure}[h!]
	\centering
		\includegraphics[width=0.35\textwidth]{bilder/ScopeFaultCompensation2.png}
	\caption{Zusammenhang zwischen Scopes, Fault und Compensation Handler}
	\label{fig:ScopeFaultCompensation2}
\end{figure}

 Als einzige Ausnahme bietet \textit{invoke}-Aktivität die Möglichkeit, eigene \textit{Fault} und \textit{Compensation Handler} zu definieren. Es entspricht einem expliziten \textit{Scope}, das die \textit{invoke}-Aktivität umschließt und \textit{Compensation} und \textit{Fault Handler} besitzt.

\subsection{Prozessinstance}
Die Erzeugung von Prozessinstanzen erfolgt implizit anhand von Aktivitäten (\textit{receive} oder \textit{pick}),
beim Eintreffen von externen Nachrichten. Die entsprechenden Aktivitäten werden mit dem Attribut \textit{createInstance}=\textit{"'yes"'} gekennzeichnet.  
Zur
Identifikation von Prozessinstanzen dienen so genannten \textit{Correlation Sets}. Diese werden von BPEL-Engine verwendet, um Nachrichten an richtige Instanzen weiterleiten zu können.

Prozessinstanzen werden beendet, wenn die Aktivitäten, die das Verhalten von Prozessen bestimmen,
abgearbeitet wurden (normale Beendigung), wenn ein Fehler den Prozess-\textit{Scope} erreicht,
der entweder behandelt oder nicht behandelt wird, oder wenn von Prozessinstanzen die \textit{exit}-
Aktivität ausgeführt wurde.


   

\subsection{Engine}
Ein BPEL-Prozess besteht aus der Geschäftslogik (definiert in BPEL), Servicebeschreibung (WSDL) und optional aus weiteren Datentypen (XML Schema). Diese Informationen werden zusammengefasst und in eine BPEL Engine deployt. Die Engine ist unter anderem dafür verantwortlich, die \textit{Endpoints} der Partner des BPEL Prozesses zu spezifizieren. Für jeden Link muss bekannt sein, welche WSDL-service und -port und welche Adresse für die Kommunikation benutzt werden sollen. Diese Information wird in so genannten \textit{Deployment Descriptoren} festgelegt.

............

