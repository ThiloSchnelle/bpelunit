Eine Möglichkeit, die Qualität zu sichern, besteht in der Ausführung der Software mit dem Ziel Fehler zu finden -- das Testen der Software.
 Testen ist ein in der konventionellen Softwareentwicklung unentbehrliches Mittel zur Qualitätssicherung.
Testen ist die in der Anwendung einfachste und wahrscheinlich verbreitetste
Methode der Verifikation und existiert in vielen Ausprägungen. 

\textit{Testen ist ein Prozess, ein Programm mit der Absicht
auszuf¨uhren, Fehler zu finden.}


Testen von BPEL ist besonders, weil BPEL Prozess externale Abhängigkeiten in Form von Web Services. Das macht das Testen schwieriger  Kompletter Systemtest kann nur durchgeführt werden, wenn alle Web Services erreichbar sind und reproduzierbare Ergebnisse liefern. Das ist vor allem bei externen Service-Anbietern schwer zu erreichen.  Anderes Problem ist das Testen gegen Fehlerbedingungen, das heißt wenn Web Service antortet Fehler oder ist nicht erreichbar.  Solche Fehlerbedingunmgen müssen simuliert werden  als Teil des Tests. 

Unit Kann bedeutend reduzieren dieses Problem beim Testen von von BPELProzessen ohne der correspondirenden Web Services. 
Im Rahmen der Forschung am Institut für Praktische Informatik (Fachgebiet Software Engeeniring) ist in ener Masterarbeit \ref{Mayer2006} BPELUnit Framework entstanden.  
 Das Framework versucht die Lücke in der xUnit Familie der Unit-testing Frameworks. 

\subsection{BPELUnit Framework}
BPELUnit für wiederholbare white-box automatisierbare BPEL Kompositionen Testen.  
  BPELUnit richtet sich primär an die Entwickler, die das Testen und Programmieren während des Entwicklungsprozesses abwechseln machen. Also bietet das  Framework schnelles Testen: Erzeugen und Ausführen sind einfach und schnell.  Unit Testen ist das Testen von Komponenten in der Isolation. BPELUnit erreicht Isolation des Prozesses durch spezielle Implementierungen ersetzt die Verwendung von Mocks, die die Partner des Prozesses ersetzte
 \begin{figure}[htbp]
	\centering
		\includegraphics[width=0.75\textwidth]{bilder/bpelProzess2.png}
		\caption{Test Harness}
	\label{fig:loggingservice}
\end{figure} 

Der Kern ist unabhängig von der Präsentationsschicht implementiert und bietet eine Schnittstelle für die Implementierung der Cliens an. Drei Clients gehören gehören zum Framework:
\begin{itemize}
	\item command line
	\item ant
	\item Eclipse plug-in mit integrierter Darstellung der Ergebnissen und einem Editor für die Erstellung der Tests 
\end{itemize}
 
Unterschiedliche BPEL Engines werden durch das Framework unterstützt und weitere können durch Erstellen entsprechender Adapter integriert werden.
  
  
Als Seiteneffekt die Tests sind sind normalerweise schneller ausgeführt, weil Web Services Simulation schneller als reale Services ist.
\textbf{BPELUnit-Architektur}.
 Das Framework basiert auf einer Schichtarchitektur, die in der Abbildung \ref{fig:schichtarchitektur} dargestellt. 
 Der erste von unten Schicht ist für die Testspezifikation zuständig und legt fest, wie die Testdaten und das Verhalten der Partner definiert werden. Die Tests werden in den Test Suiten organisiert, wofür die \textit{Test Organization}-Schicht verantwortlich ist. Die Ausführung der Tests wird in der dritten Schicht \textit{Test Execution} realisiert. \textit{Test Results}-Schicht sorgt für die Sammlung der Daten und Statistiken  während der Tests.  Im folgenden werden die einzelnen Schichten etwas näher erläutert.
 \begin{figure}[htbp]
	\centering
		\includegraphics[width=0.47\textwidth]{bilder/FrameworkLayer.png}
		\caption{Schichtarchitektur des BPELUnit Frameworks}
	\label{fig:schichtarchitektur}
\end{figure}
  
 
 \textbf{Testspezifikation}.
 Ein BPEL-Prozess hat einen Client und beliebige Anzahl von Partner. Die Partner bzw. die Web Services laufen parallel ab und interagieren dabei mit dem BPEL-Prozess. 
Das Verhalten der Partner während der Tests wird in den Testcases definiert. Zu diesem Zweck sieht jeder Testcase so genannten \textit{Tracks} vor: einen \textit{Client-Track} und beliebig viele \textsl{Partner-Tracks}. Die Tracks definieren die Interaktionen der jeweiligen Partner mit dem BPEL-Prozess anhand von Sequenzen der atomaren Interaktionen (Aktivitäten).
Dabei werden folgende Interaktionsmuster unterstützt: 
\begin{itemize}
	\item \textit{one way}-Interaktion: \textit{receive} oder \textit{reply},
	\item synchrone \textit{two way}-Interaktion: \textit{receive-reply} und \textit{reply-receive},
	\item asynchrone \textit{two way}-Interaktion: \textit{receive-reply} und \textit{reply-receive}.
\end{itemize}

 \begin{figure}[htbp]
	\centering
		\includegraphics[width=0.8\textwidth]{bilder/TestcaseSequence.pdf}
		\caption{Schichtarchitektur des BPELUnit Frameworks}
	\label{fig:schichtarchitektur}
\end{figure}


 Die Daten, die bei der Interaktion mit BPEL-Prozess verschickt werden, sind in XML spezifiziert. Es können WSDL-Nachrichten und sowohl einfache Datentypen als auch Elementen der XML Schema verwendet werden. Die Daten, die der BPEL-Prozess verschickt, können auf die Korrektheit überprüft werden  
Für die Auswahl der relevanten Daten wird XPath eingesetzt. Mittels Daten, die an BPEL-Prozess geschickt werden, können bestimmte Zweige des Prozesses werden.

Mit der Fähigkeit des Frameworks, die SOAP Faults zu  empfangen und zu senden, steht dem Tester die Möglichkeit zur Verfügung, die Fault und Compensation Handler des BPEL-Prozesses zu testen.  
 
 
\textbf{Testorganisation}.  
Die einzelnen Testfälle werden wie in den konventionellen Programmiersprachen in einer suite organisiert. Suite referenziert alle für den Test notwendigen Elemente: zu testende BPEL-Komposition, WSDL Beschreibungen, XML-Schemata usw. Außerdem definiert die Suite für alle enthaltenen Testcases eine globale Testumgebung mit einer setup und shutdown-Routine, die für das Deployment und Undeployment der Partner zuständig ist. 

\textbf{Ausführung der Tests}. Zum Testen muss der BPEL-Prozess in einer Testumgebung ausgeführt werden, die die Input- und Output-Daten des BPEL-Prozesses entsprechend der Testspezifikation behandelt. \textit{Real-life}-Testen heißt der Ansatz, der bei BPELUnit Framework dafür verwendet wird. Dabei wird der zu testende BPEL-Prozess in eine BPEL-engine deployt und als Web Service aufgerufen. Die Partner-Web Services müssen dabei durch Mocks ersetzt werden, die das Verhalten der normalen Web Services simulieren, d.h., Web Service-Aufrufe empfangen und/oder selbst absetzen.   Beim Deployen des BPEL-Prozesses müssen alle URIs der Partner-Web Services durch die URIs der Mocks ersetzt werden. 

Die Testumgebung ist neben der Simulation der Partner auch für die Kommunikation mit dem BPEL-Prozess verantwortlich, die über SOAP-Nachrichten statfinden. Zu diesem Zweck simuliert BPELUnit den kompletten Web Service Stack und kommt mit allen wichtigen SOAP-Konstrukten zu recht. Das Framework erledigt sowohl das Verpacken der Daten in SOAP-Nachrichten als auch dekodieren der empfangenen SOAP-Nachrichten (siehe \ref{fig:bpelmiddleware}) und übernimmt damit dem Tester viel Arbeit.
  
  
 \begin{figure}[htbp]
	\centering
		\includegraphics[width=0.98\textwidth]{bilder/BPELUnitMiddleware.pdf}
		\caption{Kommunikation zwischen BPEL-Prozess und simulierten Partnern}
	\label{fig:bpelmiddleware}
\end{figure}


Für das Deployment eines BPEL-Prozesses sind bei den meisten BPEL-Engines anbieterspezifische \textit{deployment descriptoren} erforderlich, die nicht standardisiert sind. Das Deployen des BPEL-Prozesses ist, wie bereits erläutert notwendig, und wird bei BPELUnit durch entsprechende anbieterspezifischen Engine-Adapter unterstützt.


\textbf{Testergebnisse}.
Beim Testen wird der BPEL-Prozess in einer Engine ausgeführt. Der beschränkte Zugriff auf den Prozess (bedingt durch die Ausführung in einer BPEL-Engine) während der Tests erschwert die Sammlung der Information über die Ausführung wesentlich. BPELUnit kann nur berichten, ob der TestCase erfolgreich war oder nicht. Im Fehlerfall wird 
werden zweiTypen von Fehlern unterschieden:
\begin{itemize}
	\item Fehler auf der Anwendungsebene - zum Beispiel eine erwartete Nachricht von BPEL ist nicht angekommen , oder enthält falsche Informationen oder zu viele Nachrichten sind angekommen,
	\item Fehler auf der Kommunikationsebene - Problem mit dem Web Service Stack.
\end{itemize}

Genau an dieser Stelle knüpft diese Arbeit an. Zusätzlich Informationen über Ausführung

 
  
