\subsection{Anforderungen}

Die Semantik darf nicht geändert werden. Die Metriken sollen einzeln gemessen werden.


Die primäre Aufgabe der Code-Coverage-Analyse liegt darin, die im Code durch Tests abgedeckten Bereiche  zu identifizieren und einige Kennzahlen der Abdeckungen zu ermitteln
(z.B. Anzahl der Durchläufe einer Codezeile). Daher werden bei der Code-Coverage-Analyse während der Testausführung
verschiedene Messungen durchgeführt, die jeweils Informationen über eine bestimmte Art der Abdeckung sammeln. Im
Folgenden werden die wichtigsten Messmetriken bei der Code-Coverage-Analyse aufgelistet.
wieviel des zu untersuchenden Codes tatsächlichdurch die Tests ausgeführt wurde. Es wird auch oft der Begriff \textit{Testabdeckung} verwendet.



\subsubsection{Normaler Kontrollfluss}
Den Kontrollfluss bestimmen in BPEL, wie bereits mehrmals erwähnt, die strukturierten Aktivitäten. In den folgenden Bildern sind die entsprechenden Kontrollflussgraphen abgebildet. Die grauen Elementen deuten an, wie die einzelnen Graphen in den Gesamtfluss eingebunden werden. Für die Zweigabdeckung relevanten Kanten sind schwarz dargestellt.
\begin{figure}[htbp!]
	\centering
		\includegraphics[width=0.65\textwidth]{bilder/h1.png}
	\label{fig:h1}
\end{figure}
\begin{figure}[htbp!]
	\centering
		\includegraphics[width=0.65\textwidth]{bilder/h2.png}
	\label{fig:h2}
\end{figure}

Bei den Aktivitäten, deren Graphen in der Abbildung vorhanden sind, entspricht der Kontrollfluss den Konstrukten, die aus vielen Programmiersprachen bekannt sind. Die Restlichen sind BPEL-spezifisch und müssen gesondert betrachtet werden.


\parpic(6.5cm,5cm)[r]{\includegraphics[width=0.30\textwidth]{bilder/pick.png}} 
\textbf{\textit{Pick}-Aktivität.}\\
Bei dieser strukturierenden Aktivität wird ein Zweig aus mehreren anhand eines Ereignisses (Nachricht oder Alarm) ausgewählt. Wurde ein zutreffendes Ereignis empfangen, so wird die zugehörige Aktivität ausgeführt und alle nachfolgenden Ereignisse verworfen. Aus der Sicht des Kontrollflusses stimmt dieses Verhalten mit dem einer IF-\-Akti\-vi\-tät überein. Deswegen werden diese beiden Aktivitäten im Kontrollfluss durch gleiche Graphen repräsentiert.

\textbf{\textit{Flow}-Aktivität.}\\
  Mit der \textit{Flow}-Aktivität wird in BPEL paralleler Ablauf mehrerer Aktivitäten realisiert. Außerdem gibt es mit dem Link-Konzept, ein mächtiges Instrument, das ermöglicht, Syn\-chro\-ni\-sa\-tions\-ab\-hän\-gig\-keiten aufzustellen und damit komplexe Abläufe zu realisieren. Die rechte Abbildung zeigt den zugehörigen Kontrollfluss. 
  \parpic(6.4cm,3.6cm)[r]{\includegraphics[width=0.33\textwidth]{bilder/flow.png}}
  Die Links (gestrichelte Pfeile) unterscheiden sich semantisch von den normalen Kanten des Kontrollflussgraphes.
  Wie es bereits im Abschnitt .. geschildert wurde, haben die Links trotzdem einen erheblichen Einfluss auf den Kontrollfluss und sind damit für die Zweigabdeckung relevant. 

  Aus der Sicht der Abdeckungsmessung ist die Tatsache besonders, dass der Status der Links drei Werte annehmen kann: \textit{true}, \textit{false} und \textit{unset}  Die normalen Kontrollflusskanten können dagegen nur zwei Werte annehmen: entweder \textit{aktiviert} oder \textit{nicht aktiviert}(\textit{unset}). Für die Links bedeutet das, dass \textit{true}- und \textit{false}-Status bei der Messung der Abdeckung erfasst werden müssen. 

\textbf{\textit{ForEach}-Aktivität.}
Die \textit{ForEach}-Aktivität sorgt für mehrmaliges Ausführen des enthaltenen Scopes. Die Anzahl der Ausführungen wird durch Start- und Stopvariablen vorgegeben. Die Besonderheit dabei ist, dass die Ausführung entweder sequenziell oder parallel erfolgen kann. Die Ausführungsart wird durch den  Wert der Variable \textit{parallel} (\textit{yes}/\textit{no}) geregelt. 

Dieses Verhalten kann durch zwei Graphen dargestellt werden. Die Abbildung ... repräsentiert sequentielle Ausführung, die einer for-Schleife aus den konventionellen Programmiersprachen entspricht. Der Graph daneben repräsentiert eine parallele Ausführung.
\begin{figure}[h!]
	\centering
		\includegraphics[width=0.73\textwidth]{bilder/forEeach2.png}
	\label{fig:forEeach2}
\end{figure}\\

Während der reguläre Kontrollfluss des Programms den Steuerfluss für alle reguläre Situationen vorgibt, gibt es in BPEL ein (\textit{FaultHandler})-Kontrollfluss, der für die Behandlung zur Laufzeit aufgetretener Fehler vorgesehen ist. Inwiefern dieses Verhalten in die Zweigabdeckung mit einfließen kann, wird im nächsten Abschnitt diskutiert. 
 In den folgenden Abschnitten werden die Metriken vorgestellt, die den Grad der durch die Tests abgedeckten Fault- bzw. Compensation Handler wiedergeben.
\\



Anweisungs¨uberdeckung wird im allgemeinen nicht als hinreichendes Kriterium
f¨ur die Vollst¨andigkeit eines Tests betrachtet, ihre Auswertung ergibt sich als
Nebenprodukt der Auswertung umfassenderer ¨Uberdeckungskriterien. Empirische
Untersuchungen zeigen eine Fehlererkennungsrate von 15\% bis unter 20\% f¨ur
reine Anweisungs¨uberdeckung. Sie liefert allerdings in allen Untersuchungen h¨ohere
Prozents¨atze als die statische Analyse des Quelltextes.
Die Kanten¨uberdeckung gilt als Standard bei kontrollflussbasierten ¨Uberdeckungsmaßen
und wird oft als Kriterium an Tests gestellt. Sie wird als leistungsf
¨ahiger Test vor allem zum Auffinden von logischen Fehlern betrachtet. Untersuchungen
bez¨uglich der Leistungsf¨ahigkeit streuen in einem weiten Bereich von
20\% bis 70\% gefundener Fehler. Zumeist liegen die Prozents¨atze im unteren Drittel
dieses Intervalls. Studien, die ebenfalls Anweisungs¨uberdeckung betrachten, zeigen
f¨ur Zweig¨uberdeckung eine Fehlererkennungsrate, die um 50% bis 100% ¨uber der
der Anweisungs¨uberdeckung liegt.
Bedingungs¨uberdeckung findet vor allem bei Systemen mit komplexer Verarbeitungslogik
Verwendung, die in der Regel kompliziert aufgebaute Bedingungen
verwende.



D

Erfolgsquote:
..Anweisungsüberdeckungstest 18%
..Zeigüberdeckungstest 32%
..Bedingungsüberdeckungstest ?
..Pfadüberdeckungstest 65%


Beim Erstellen von Tracedaten unterscheidet man zwischen Methoden, die es erfordern
den bestehenden Source- bzw. Objektcode zu instrumentieren und Methoden,
die automatisch Traceausgaben erzeugen. Moderne Entwicklungsumgebungen bieten
meist Techniken an, um Traceausgaben ohne Sourcecode-¨Anderung zu erstellen.


Die Testabdeckungsanalyse gibt an, in welchem Umfang die durchgeführten Tests die zu testende Software erfasst haben.



Bis jetzt wurde Instrumentierungsansatz allgemein betrachtet, ohne auf eine bestimmte Sprache einzugehen. Jetzt werden BPEL-spezifische Einschränkungen untersucht. Als Erstes dürfen nur BPEL-Aktivitäten eingefügt werden, sonst kann der BPEL-Prozess von der BPEL-Engine nicht ausgeführt werden. Um Protokollierung zu realisieren, muss eine Kommunikation von der Ausführungsumgebung nach außen stattfinden. Die einzige dafür geeignete Aktivität ist \textit{invoke}. Außerdem muss ein (lokales) Web Service eingerichtet werden, der für das Protokollieren zuständig ist. Bevor zu tief in die Details eingestiegen wird, werden zuerst die anderen Lösungsmöglichkeiten vorgestellt und besprochen.	
	
	
	\begin{itemize}
\item BPEL-Prozesse werden in speziellen Ablaufumgebungen (\textit{BPEL-Engine}) ausgeführt.
\item BPEL-Prozesse können nur mit Web Services (\textit{partner}) kommunizieren.
\begin{itemize}
	\item Die entsprechenden WSDL-Beschreibungen sind notwendig.
	\item Die \textit{partner link types} und \textit{partner liks} müssen definiert werden
\end{itemize}
	\item Businesslogik wird in BPEL-Prozesse durch BPEL-Aktivitäten (s. Abschnitt \ref{}) realisiert. 
\end{itemize}

\begin{figure}
	\centering
		\includegraphics[width=0.90\textwidth]{bilder/loggingservice.pdf}
	\label{fig:loggingservice}
\end{figure}



\newpage
\begin{figure}[h!]
	\includegraphics{bilder/StrukturedAktvities/sequence.pdf}
	\label{fig:sequence}
\end{figure}
\begin{figure}[h!]
	\includegraphics{bilder/StrukturedAktvities/pick.pdf}
	\label{fig:pick}
\end{figure}
\begin{figure}[h!]
	\includegraphics{bilder/StrukturedAktvities/while.pdf}
	\label{fig:while}
\end{figure}
\begin{figure}[h!]
	\includegraphics{bilder/StrukturedAktvities/flow.pdf}
	\label{fig:flow}
\end{figure}


Protokolliert man eine Aktivität, die das Ziel eines oder mehreren Links ist, davor, so kann es sein, dass sie aufgrund der transition- bzw. joinCondition gar nicht ausgeführt wird.
      \lstinline|print "hello world"|
      
      
      \lstset{emph={joinCondition,target }, emphstyle=\color{blue}}
      \begin{lstlisting}[caption=Beispielcode]{Name}
<flow>
  <links>
    <link name="CtoD"/>
  </links>
  <receive name="C" ...>
    <source linkName="CtoD"/>
  </receive>
  <invoke ... joinCondition=...>
    <target linkName="CtoD"/>
  </invoke>
</flow>      \end{lstlisting}

\lstset{emph={[2]sequence}, emphstyle=[2]\color{red}}
      \begin{lstlisting}[caption=Beispielcode][firstnumber=1]{Name}
<flow>
  <links>
    <link name="CtoD"/>
  </links>
  <receive name="C" ...>
    <source linkName="CtoD"/>
  </receive>
  <sequence joinCondition=...>
    <target linkName="CtoD"/>
    <!--Logging-->
    <invoke .../>
    <!--Logging-->
  </sequence>
</flow>      \end{lstlisting}

Für die Messung heisst es, während es bei normalen Kanten ausreichend ist, die aktivierten Kanten zu erfassen, muss es bei den Links zusätzlich zwischen \textit{true}- und \textit{false}-Status unterschieden werden. 


Drei Elemente bilden die Grundlage von Web Services:
Die Übermittlung: Die Kommunikation zwischen Service-Anbieter, Service-Konsument und ggf. Service-Verzeichnisdienst erfordert die Übermittlung von Nachrichten. 
Es hat sich SOAP durchgesetzt.  Dieser von W3C verwaltete Standard basiert auf XML und liegt in der Version 1.2 vor.



  Die
Nutzung etablierter und standardisierter Internetstandards f¨ur Transport undDatenstrukturierung stellt dabei die Interoperabilit¨at bei der Kommunikation
zwischen Softwarekomponenten sicher.
Die Entwicklung der eingesetzten Standards wird vom W3C und anderen
Standardisierungsgremien geleitet, wobei die Aufgabe haupts¨achlich in der Definition
und Pflege bereits etablierter Standards der Web-Servicearchitektur
besteht. Die Web-Servicearchitektur des W3C ist dabei kein fest vorgegebener
Rahmen, sondern definiert lediglich die minimalen Anforderungen welche eine
Softwarekomponente erf¨ullen muß, um als Web-Service zu gelten.
Trotz der Offenheit der Web-Servicearchitektur haben sich die Beschreibunsstandards
Simple Object Access Protocoll (SOAP), Web-Service Description
Language (WSDL) und Universal Description, Discovery and Integration
(UDDI) als Kern dieser Architektur etabliert.
Diese Standards basieren auf XML und XML-Schema, so daß XML-f¨ahige
Applikationen Dokumente welche auf diesen Standards beruhen verarbeiten
k¨onnen. Zusammen mit der Nutzung von etablierten Netzwerk¨ubertragungsprotokollen
ergeben sich somit gute Kommunikationseigenschaften.
Mit SOAP steht dabei eine Beschreibungssprache zur strukturierten Daten-
¨ubertragung zur Verf¨ugung. Es wird heute haupts¨achlich zur strukturierten
Beschreibung von Nachrichten und ihren Parametern eingesetzt. WSDL ist
ein plattformunabh¨angiger Standard zur Beschreibung der Schnittstellen von
Softwarekomponenten. UDDI ist ein Beschreibungsstandard zur Kategorisierung
und Beschreibung von Eintr¨agen in einem Verzeichnissystem für Dienste
im Allgemeinen. UDDI erlaubt es dabei neben allgemeinen Informationen zur
ver¨offentlichenden Institution, technische Daten zur Beschreibung der angebotenen
Dienste zu publizieren. Diese drei Standards werden in den folgenden
Abschnitten eingehend behandelt.Den Kern der Architektur bilden die zentral dargestellten Komponenten zum
Nachrichtenaustausch (Messages), zur Schnittstellenbeschreibung von Services
(Descriptions) und zur Komposition von Services zu komplexen Gesch¨aftsprozessen
(Processes). Aus der Abbildung ist ersichtlich, daß die genannten Komponenten
auf XML und XML-Schema basieren, was eine plattform¨ubergreifende
Nutzbarkeit garantiert.
Die vom W3C definierte Web-Servicearchitektur soll in erster Linie die Interoperabilit
¨at der angebotenen Dienste sicherstellen. Details zur Implementierung
oder zu Transport und Strukturierung der Daten werden dabei bewußt
nicht definiert. Die Unterstützung des Nachrichtenaustausches von Softwarekomponenten
¨uber Netzwerke charakterisieren Web-Services als Middleware für
verteilte Systeme. Wichtigste Eigenschaften von Web-Services sind dabei ihre
lose Kopplung, ihre Programmierbarkeit über selbstbeschreibende Schnittstellen,
sowie Orts- und Protokolltransparenz.


Die Beschreibung:  Der Service und die von ihm zur Verfügung gestellten Methoden müssen beschrieben werde, damit der Service-Konsument weiß, was der Dienst ihm bietet. WSDL ist der Standard. wird wie SOAP von W3C verwaltet. Version 1.2 ...

Der Verzeichnisdienst:

Die Standards für diese drei Grundelemente bilden das Fundament für Web Services.

\begin{itemize}
	\item SOAP ein standardisiertes, XML-basiertes
Protokoll zum Verpacken von Nachrichten, die zwischen Applikationen ausgetauscht
werden. setzt SOAP
auf die Netzwerk- und Transportschichten auf. Es ist also irrelevant, welche
Transportmechanismen f¨ur den eigentlichen Versand verwendet werden.Die gebr¨auchlichste Form des Austausches von SOAP-Nachrichten ist die ¨Ubertragung
¨uber HTTP.
\item UDDI
dient zur Lokalisierung und Veröffentlichung
von Web-Services im Internet
UDDI = Register für Diensteund ihre Beschreibungen+ Suchmethoden+ Publishingmethoden
UDDI-Daten enthalten Kontakt-Informationen, Listen von Business Services und Infos, wie einService via Protokoll angesprochen werden kann
Um einen Web-Service im Internet zu finden, ist ein Verzeichnisdienst notwendig.
F¨ur diese Zwecke wurde der Universal Description, Discovery and Integration-
Standard geschaffen. UDDI bietet Standardfunktionen zum Klassifizieren,
Katalogisieren und Verwalten von Daten und Metadaten ¨uber Web-
Services, so daß diese einfach gefunden und verwendet werden k¨onnen.
\item WSDL (Web Services Defnition Language) ist eine funktionale, XML-basierte Beschreibungssprache
für die Schnittstellen eines Web Services.
\end{itemize}


Web S basieren, zumindestens in der Grundfunktionalität (Nachrichtenübermittlung, Beschreibung und Verzeichnisdienste) auf anerkannten standards. 
Web Services können folgendermaßen definiert werden:


Drei Grundlegende Standards.
SOAP
Die SOAP-Spezifikation definiert ein Rahmenwerk für die Übertragung von XML-Nachrichten über ein standardisiertes und anerkanntes Transportprotokoll.
  Nachrichtenaustausch
Anwendungen können Nachrichten (z.B. Aktienkurse, Warenbestellungen) in XML codieren undviaSOAP-Dokumenten austauschen
Durch XML liefert SOAP eineplattformunabhängigesProtokoll
für den Nachrichtenaustausch
SOAP stellt Konventionen für eine standardisierte Darstellungsweiseder Informationen in XML für den Datenaustausch in heterogenen Systemen zur Verfügung
SOAP liefert zwei Ansätze für den Nachrichtenaustausch:
Remote Procedure Calls
Funktionsaufrufe entfernter Prozeduren im Sinne verteilter Architekturen
ElectronicDocument Interchange
Dokument-basiertes SOAP, bei dem fachliche Dokumente z.B. Steuererklärung, Warenbestellungen ausgetauscht werden
 Bei der Entwicklung legte man
großen Wert auf Erweiterbarkeit, Offenheit und Heterogenität des Protokolls.
SOAP besteht im Wesentlichen aus vier Teilen:
 der Spezifikation für einen Umschlag (Envelope). Für ihn ist definiert, was in einer
Nachricht enthalten ist, von wem es wie verarbeitet werden soll und ob einzelne Daten
optional sind oder enthalten sein müssen.
 ein Satz von Regeln, die vorschreiben, wie Daten in dem Umschlag repräsentiert werden
sollen (Serialisierung)
 eine Konvention, um Remote Procedure Calls und eventuelle Antworten auf diese zu
repräsentieren
 eine Vorschrift, wie SOAP via HTTP übertragen werden soll. Dank des erweiterbaren
Entwurfs können aber beliebige Transportprotokolle verwendet werden.
Eine SOAP-Nachricht muss nicht zwangsläufig direkt vom Sender (initial sender) an den
Empfänger (ultimate receiver) geschickt werden, sondern kann über mehrere Relay-Stationen
(intermediaries) geleitet werden. Den Weg, dem sie dabei folgt, nennt man Message Path.
SOAP macht jedoch keine Angaben dazu, in welcher Reihenfolge die Stationen abgearbeitet
werden. Es gibt aber einige SOAP-Erweiterungen, die diese Lücke zu füllen versuchen.
Der SOAP-spezifische Teil einer Nachricht wird über die Zuordnung zu bestimmten Namensräumen
erkennbar.
Das Simple Object Access Protocol bietet ein standardisiertes, XML-basiertes
Protokoll zum Verpacken von Nachrichten, die zwischen Applikationen ausgetauscht
werden. Es bietet einen Mechanismus zum Austausch typisierter Daten
in einem dezentralen, verteilten Umfeld und l¨aßt sich leicht mit verschiedenen
¨Ubertragungsprotokollen nutzen. Die Grundidee ist, daß zwei Anwendungen
Informationen ¨ubertragen k¨onnen, ohne daß auf das Betriebssystem, die Programmiersprache
oder andere technische Implementierungsdetails R¨ucksicht genommen
werden muß. F¨ur diesen Informationsaustausch wird dabei nichts weiter
ben¨otigt als eine Nachricht, die so codiert ist, daß beide Anwendungen sie
verstehen k¨onnen. Eine versendete Nachricht kann dabei jede beliebige Information
enthalten: eine Suchanfrage an eine Suchmaschine oder ein Warenhaus,
die Suche oder Buchung eines Fluges oder einer Zugfahrt, die Abfrage eines
Aktienkurses, eine Warenbestellung etc.
Urspr¨unglich begann Microsoft 1998 mit der Entwicklung von SOAP. Sp¨ater
beteiligten sich andere Firmen wie IBM und SAP an der Standardisierung. Seit
September 2000 wird die Weiterentwicklung des Standards durch eine Arbeitsgruppe
des W3C koordiniert, wodurch Offenheit und Herstellerunabh¨angigkeit
gew¨ahrleistet ist. Die aktuelle Version ist SOAP 1.2 ([SOAP Pt. 1] und
[SOAP Pt. 2]).Als standardisiertes Protokoll zum Verpacken von Nachrichten 

WSDL 

Web Service Technologie Stack
basieren Web Services auf einer Reihe zusammen-
hÄangender Technologien.


XML Schema: Der Standard beschreibt die Struktur
oder das Format von XML-Daten. Auf diese Weise
kann ein Programm, welches die Daten zur
Bearbeitung erhält, erkennen, ob es sich dabei
beispielsweise um Zahlenwerte oder
Aufzählungstypen handelt.
SOAP (Simple Access Protocol): Dieser Standard
sorgt für die zuverlässige Übermittlung elektronischer
Nachrichten zwischen Geschäftsanwendungen über
das Internet. SOAP wurde von IBM, Lotus und
Microsoft entwickelt.
WSDL (Web Services Describtion Language):
Dieser Standard beschreibt, wie Programme über das
Internet oder andere Netze miteinander
kommunizieren. WSDL dient der eindeutigen
Definition von Nachrichtenformaten und Protokollen.
WSDL wurde von IBM und Microsoft entwickelt.
UDDI (Universal Description Discovery and
Integration): Mit dem Standard können
Unternehmen eigene technische Spezifikationen über
E-Business-Regeln untereinander austauschen.
UDDI wurde von IBM, Microsoft und Ariba entwickelt.


  Die SOAP-Spezifikation definiert ein Rahmenwerk für die Übertragung von XML-Nachrichten über ein standardisiertes und anerkanntes Transportprotokoll.
  
  WSDL ist ein XML-Dialekt, der fehlende, aber oft notwendigen Metadaten für Web Services beschreibt. WSDL ist jedoch nicht allein an SOAP gebunden. Es gibt eine Vielzahl von vordefinierten Bindungen, zu denen auch SOAP 1.1 zählt. WSDL hält sich an eine abstrakte Beschreibung von Web Services. WSDL verfolgt somit unterschiedliche Ziele:

	Erweiterbarkeit: Neue Codierungsvarianten und Transportmechanismen können definiert werden.
 	Abstrakte Definitionen: Nachrichten und Dienste werden abstrakt beschrieben, können aber auf eine oder mehrere konkrete Implementierungen abgebildet werden.
 	Wiederverwendung von Definitionen: Vorhandene Definitionen von Endpunkten können für neue Definitionen wiederverwendet werden.


Grundlegendes
   Eine WSDL-Datei besteht aus mehreren XML-Elementen und entsprechenden Kindelementen. Abbildung 2 enthält die grafische Darstellung der einzelnen Elemente von WSDL. Diese werden in den folgenden Abschnitten näher erläutert. Eine WSDL-Beschreibung beginnt immer mit dem Element definitions. Direkt in diesem Element werden die im Dokument verwendeten Namensräume als Attribute definiert. Sämtliche anderen in der WSDL-Beschreibung vorkommenden Elemente sind Kinder dieses Wurzelelements.
   





aaaaaaaaaaaaaaaaa












Wichtig:
Web Service realisierung von SOA

basiert auf mehreren Standards

Unterstützt von großen Insustrie .. IBM Microsoft Sun



Definition von W3C


Daraus: Web Service Software anwendung, beliebiger Größe

Selbstbeschreibend, XML

Web Services interagieren mit mit anderen Software agenten, nicht mit Menschen

Web intenet basierte Protokolle


Die wcihtigsten Standards:


SOAP WSDl UDDI

Stack

Diese Arbeit hat mit Web Service Composition (speziell BPEL) zu tun ganz oben auf dem Stack 
BPEL setzt auf WSDl und SOAP.

Web Services sind nicht zur menschlichen Informationsverarbeitung geschaffen,
sondern für die Kommunikation zwischen Anwendungen und Computern.

Web Services sind durch begleitende Metadaten (Beschreibungsmerkmale:
Name, Version, Beschreibung, etc.) selbstbeschreibend und bieten somit
zur Laufzeit Auswertungsmöglichkeiten für weitere Services. Web Services
sind in sich gekapselte und abgeschlossene, unabhängige Anwendungen, die
für eine genau definierte Aufgabe geschaffen wurden.
Web Services sind lose gekoppelt. Die Kommunikation zwischen den Anwendungen
geschieht ausschließlich über den Nachrichtenaustausch, wobei
dem Nutzer Implementierungsdetails verborgen bleiben. Es erfolgt keine Festlegung
bezüglich konkreter Implementierung und verwendetem Kommunikationsprotokoll.
Web Service sind ortstransparent und können somit jederzeit von jedem
Ort aus angesprochen und verwendet werden.
Web Services sind protokolltransparent und unterstützen mehrere Protokolle
für die Übertragung und Verarbeitung von Nachrichten.



Eine Defnition zu Web Services findet man bei Pera und Rintelmann.
Defnition: Der Begrif Service oder Dienst meint eine Software-Einheit, die in sich abgeschlossen
ist und, auf eine Kommunikationsplattform und einen Namensraum bezogen, frei
verteilbar und auch wieder lokalisierbar ist. Ein solcher Service ist nur lose mit anderen Services
gekoppelt deren Schnittstellen über XML-Artefakte definiert sind. Web Services sind
Services mit der Besonderheit, dass sie sich der Kommunikationsmechanismen des Web bedienen. [PR05]
Web Services sind zurzeit die beste Lösung für die Integration von verschiedenen, autonomen EBusiness-
Systemen. Diese werden in Unternehmen eingesetzt, um eine flexible Software-Architektur
zu gewährleisten. Die immer wiederkehrenden Funktionen im Unternehmen werden nur einmal implementiert
und anderen Programmen als Services zur Verfügung gestellt. Diese Vorgehensweise erlaubt
es den Unternehmen   fexibel den Prozessablauf an die geänderten Anforderungen anzupassen, um auf
die Marktveränderungen schnell reagieren zu können. Dadurch können Redundanzen vermieden und
Kosten in der Entwicklung gesenkt werden. Die Implementierungsdetails bleiben vor dem Benutzer
verborgen, denn die beiden Teilnehmer müssen nur die Schnittstellendefinition kennen. Die Trennung
des Designs und der Entwicklung erlaubt eine fachliche Aufteilung der zu erstellenden Geschäftsprozesse.
Unabhängig voneinander können die Fachbereiche auf ihre Aufgabe abgestimmte Prozesse
defnieren und anderen Fachbereichen diese als Service zur Verfügung stellen. Bei Änderungen muss
anschlieÿend nur der Service geändert werden, wenn es keine so gravierenden Änderungen gab, die
sich bis auf die Schnittstelle auswirken konnten. Nach der durchgeführten Änderung steht der Service
wieder allen anderen Geschäftsprozessen zur Verfügung. Dadurch wird allen Geschäftspartnern
eine hohe Qualität der Software bereitgestellt, was sich auch in den niedrigeren Gesamtkosten eines
Projektes widerspiegelt.


Web Services Defnition Language (WSDL)1 ist eine funktionale, XML-basierte Beschreibungssprache
für die Schnittstellen eines Web Services. Ein Web Service repräsentiert sich nach auÿen
über seine WSDL-Dokumentstruktur, die zunächst jedem Web Service vorgegeben werden muss. Eine
WSDL-Datei beschreibt nichts anderes als die abstrakten Eigenschaften eines Web Services. Sie
stellt die Grundlage für die spätere Definition des Geschäftsprozesses dar, da diese die Informationen
sowohl zu Messagetypen als auch zu Schnittstellendefnitionen der beteiligten Prozesse enthält. Es
beschreibt eine Sicht auf ein Web Service und aller darin beteiligten Rollen. In den Ports werden alle
aufrufbaren Operationen defniert.
Die WSDL-Dokumentstruktur ist eine Menge von Defnitionen, die folgende Elemente beinhaltet.
Das Wurzelelement eines WSDL-Dokumentes bildet das <definitions>-Element. Es enthält den
Namen des Services, Namespaces für den Service und verwendete Standards. Jedes WSDL-Dokument
besteht immer aus zwei folgenden Teilen, dem mehrfach verwendeten abstrakten und dem konkreten
Teil. Im abstrakten Teil werden die <types>-, <message>- und <portType>-Elemente und in dem
konkreten Teil die <binding>- und <service>-Elemente defniert. Im konkreten Teil wird also
beschrieben, wie und wo auf einen Web Service zugegrifen werden soll, und im abstrakten Teil,
welche Typen und Nachrichten daran beteiligt sind.
Das nächst folgende Listing zeigt die Grundstruktur eines WSDL-Dokumentes. Die Web Services
werden hauptsächlich über folgende Elemente beschrieben.



Im Folgenden werden die Elemente eines WSDL-Dokumentes einzeln beschrieben und näher erl
äutert. Die dazu entsprechende WSDL-Instanz kann im Anhang A nachgeschlagen werden.
<types> - Dieses Element kapselt die Defnition von Datentypen eines Web Services ein, die für
die auszutauschenden Nachrichten benötigt werden. Zur Defnition der Datentypen greift WSDL auf
das XML-Schema zurück. Die Defnition der Typen wird in Verbindung mit Ein- und Ausgabedaten
in EPK eine besondere Rolle spielen.
<message> - Dieses Element defniert Nachrichten, die zwischen den Partnern verschickt werden.
Die Parameter werden durch das Kind-Element <part> beschrieben. Jede Nachricht kann aus
einem oder mehreren <part>-Elementen bestehen. Das Element <part> ist vergleichbar mit dem
Parameter eines Funktionsaufrufs und wird durch den Namen und seinen Datentypen eindeutig festgelegt.
Das <message>-Element legt somit eindeutig fest, welche Eingaben ein Web Service benötigt
und welche Ausgaben dieser erzeugt.
<portTypes> - ist eines der wichtigsten Elemente in einem WSDL-Dokument. Ein BPEL-Prozess
kommuniziert mit anderen Web Services über dieses Element. Es beschreibt ein Web Service mit
seinen Operationen, die an einem Port ausgeführt werden. Dieses darf eine beliebige Anzahl die
an diesem Port unterstützenden Operationen defnieren. Es bündelt alle Operationen mit seinen
beteiligten Nachrichten und stellt somit die abstrakte Schnittstelle eines Web Services dar. Es können
entweder eingehende oder ausgehende Operationen verwendet werden.
<operation> - Dieses Element wird in <portTypes> und in <binding> verwendet und kapselt
in sich die Funktionalität eines Web Services. Eine Operation kann folgende Eigenschaften haben. Die
Namen, die in der Spezifikation verwendet werden, lauten <wsdl:one-way-operation>, <wsdl:requestresponse-
operation>, <wsdl:solicit-response-operation> oder auch
<wsdl:notification-operation>. Die beiden Typen <wsdl:one-way-operation> und <wsdl:requestresponse-
operation> werden als inbound operations definiert, weil diese von Web Services angeboten
werden, in dem diese von den eingehenden Nachrichten getriggert werden. Die letzten beiden
Operationenarten werden outbound operations genannt.
<binding> - ist die Defnition des Kommunikationsprotokolls für jeden Port und des Nachrichtenformats.
Die abstrakte <portType>-Schnittstelle wird über das Binding-Element an konkrete
Protokolle angebunden.
<port> - Ein konkreter Web-Service-Endpunkt wird über das <port>-Element eindeutig identi-
fiziert.
<service> - Dieses Element enthält alle <port>-Elemente und beschreibt somit die Menge der
Ports zu jedem einzelnen Service. Es fasst alle Endpunkte eines Web Services zusammen.
<ExtensibilityElements> - werden im Zusammenhang mit BPEL-Prozessen verwendet. Es werden
hier BPEL-Elemente wie <partnerLinkTypes> definiert. Die <partnerLinkTypes> werden
über ihre <role> und ihre <portTypes> identifiziert. Das heißt, dass die Charakterisierung über
<partnerLinkType> erfolgt, indem jedem Web Service eine bestimmte Rolle zugeordnet wird. EineRolle repräsentiert eine Ressource und kapselt eine Berechtigung in sich ein. Die bereitgestellten Ports
von beiden Partnern legen eindeutig die Endpunkte für die benutzten <partnerLinks> fest. Diese
sind für Basis-Aktivitäten relevant, die Web-Service-Requests auslösen können und charakterisiert
damit zugleich eine Beziehung zwischen zwei oder mehreren Web Services.











%--Business Process Execution Language for Web services
De¯nition 2.1 (Web Service).
Ein Web Service ist eine abgeschlossene, selbsterklÄarende und modulare Software-
Komponente, die Äuber das Internet verÄo®entlicht, aufgefunden und benutzt werden kann.
Ein Web Service stellt eine beliebig komplexe FunktionalitÄat zur VerfÄugung. Ein verÄo®ent-
lichter Web Service wird mit einer anderen Anwendung (mÄoglicherweise ebenfalls ein Web
Service) zu einem neuen System komponiert. Der Nachrichtenaustausch zwischen Web
Service basiert zumeist auf dem XML-Format.

Ein Web Service ist somit eine o®ene Komponente mit einer wohl de¯nierten Schnittstelle
zur Au¼enwelt. Alle zur Benutzung notwendigen Informationen Äuber einen Web Service
sind in der Äo®entlich zugÄanglichen Beschreibung seiner Schnittstellen enthalten.

Web Service Technology Stack
Nun beschÄaftigen wir uns detaillierter mit der Architektur von Web Services. Im Gegensatz
zum monolithischen Stil frÄuherer AnsÄatze  In diesem Zusammenhang fÄallt hÄau¯g der Begri® des Technology
Stacks. Abbildung 2.2 veranschaulicht dessen Aufbau in Anlehnung an [Sle01].
Den Kern (genannt Core Layers) bilden bereits etablierte Technologien. Durch den RÄuck-
gri® auf weitgehend akzeptierte Standards gelingt es mit dieser Schicht, zu fast allen exis-
tierenden Systemen kompatibel zu sein und eine Hard- und Software-unabhÄangige Basis fÄur
die aufbauenden Schichten zu scha®en. Zu den Kern-Schichten zÄahlen:
Transport
DerWeb-Service-Ansatz ist an kein bestimmtes Transport-Protokoll gebunden, um die
FlexibilitÄat nicht einzuschrÄanken. Doch die Verwendung weit verbreiteter Protokolle
wie TCP/IP und HTTP ist Äublich, um Web Services in jedem Umfeld { vor allem
auch Äuber Firewalls hinweg { zugÄanglich zu machen. [Kre01]
Extensible Markup Language (XML)
XML ist ein allgemein anerkanntes Datenformat zum Austausch von Informationen

zwischen verschiedenen Anwendungen. Aufgrund seiner FlexibilitÄat und Erweiterbar-
keit wird XML als Grundstock der meisten Schichten im Web Service Technology
Stack verwendet. [BPMM00]
Simple Object Access Protocol (SOAP)
SOAP unterstÄutzt die Kodierung beliebiger Daten (normalerweise in XML) und deren
Transfer (z. B. Äuber HTTP). Im Zusammenhang mit Web Services ist SOAP u. a. eine
Programmiersprachen-unabhÄangige Version von RPC (Remote Procedure Call). Pa-
rameter des Funktionsaufrufs und Antworten werden ebenfalls in der SOAP-Nachricht
kodiert. [BEK+00]
Die hÄoheren Schichten, hier als Emerging Layers bezeichnet, umfassen die neuen Technologien.
Diese Technologien be¯nden sich teilweise noch im Entwicklungsstadium oder werden zur
Zeit standardisiert. Als feste Bestandteile des Technology Stacks gelten:
Web Services Description Language (WSDL)
WSDL ist eine XML-basierte Sprache, mit der spezi¯ziert wird, welche Operationen
der Web Service zur VerfÄugung stellt und wie die Verbindung mit dem Web Ser-
vice ablaufen soll. Die Konzeption von WSDL sieht eine grobe Zweiteilung vor: Der
abstrakte Teil de¯niert sprach- und plattformunabhÄangige Typen, Nachrichten, Ope-
rationen und Port-Typen. Der konkrete Teil { genannt binding { bildet die abstrakten
Elemente auf konkrete Datenstrukturen, Protokolle und Adressen ab. [CCMW01]
Universal Description, Discovery, and Integration (UDDI)
UDDI ist die globale Verzeichnisstruktur fÄur Web Services und gleichzeitig ein Pro-
tokoll, um Web Services zu suchen und zu verÄo®entlichen. Eine UDDI-Registrierung
besteht aus den Wei¼en, Gelben und GrÄunen Seiten:




Die Web Services Description Language (WSDL) ist eine Schnittstellenbeschreibungssprache
für Web Services und wurde im September 2000 in der
Version 1.0 vorgestellt. Seit März 2006 liegt die Version 2.0 als W3C Candidate
Recommendation vor.
Mit WSDL können Web Services formal beschrieben werden, damit Applikationen
automatisiert auf die angebotenen Dienste zugreifen und diese
einbinden können. Innerhalb des WSDL-Dokuments werden die angebotenen
Funktionen, die verwendeten Datentypen, die Struktur der Aufrufnachricht
und des Ergebnisses und das Austauschprotokoll spezifiziert. Im Wesentlichen
werden die von außen zugänglichen Operationen definiert, sowie deren
Parameter und Rückgabewerte. (vgl. Wik06)
In WSDL gibt es sechs Hauptelemente, die sich in zwei Gruppen aufteilen
lassen - die abstrakten und die konkreten Definitionen.

Kritikpunkte von WSDL sind die fehlenden semantischen Spezifikationen
eines Web Services. WSDL spezifiziert lediglich die syntaktischen Elemente eines Web Services, d.h. wie ein Client auf den entsprechenden Web
Service zugreifen kann. Darüber hinausgehende semantische Spezifikationen
eines Web Services sind allerdings oft wünschenswert [...]. (Wik06) Mit
WSDL können keine Informationen über die Antwortzeit, Kosten des Services,
Security-Bestimmungen und genauen Effekte einer Operation definiert
werden. Diese werden allerdings zur automatischen Auffindung und Orchestrierung
(siehe Kapitel 5.2, S.23) von Services benötigt.


An WSDL wurden hohe Anforderungen geknüpft. Es soll die Service-Schnittstellen
Programmiersprachen- und Programmierparadigmen-neutral definieren, darüber
hinaus abstrakt und erweiterbar sein.

%ebigo

   
   Web Services sind eine Realisierung einer SOA, mit der sich Informationsdienste im WWW automatisieren lassen. Es handelt sich dabei um funktionale Dienste, die über Internetprotokolle und die Internet-Infrastruktur übertragen werden können. In den meisten Fällen sind Web Services Software-Komponenten, die mittels Applikationsserver im Internet nutzbar gemacht werden. Um Daten miteinander auszutauschen, werden XML-basierte Standards verwendet.
   
    	

Web Services sind funktionale Dienste, die über Internetprotokolle und damit der Internet-Infrastruktur übertragen werden können. Die mit Web Service Diensten verbundenen Protokolle und Standards wie SOAP, WSDL und UDDI bilden den technologischen Rahmen für die Realisierung anspruchsvoller Szenarien in verteilten Anwendungen.


SOA
Mehr Argumente für SOA: SOA-Expertenforum der Computerwoche
Jeder der oben genannten Punkte hat mehrere konkrete Vorteile für ein Unternehmen:

Business Innovation

- Schnellere Umsetzung von Fusionen und Übernahmen

- Neue Produkte und Angebote durch Neubündelung vorhandener Leistungen

- Verbesserte Kundenzufriedenheit durch innovative Angebote

Anwenderproduktivität

- Gesteigerte Produktivität durch intuitive Benutzeroberflächen auf Basis von AJAX führen zu mehr Transaktionen pro Zeiteinheit

- Reduzierter Trainingsaufwand

- Weniger operative Fehler durch Vermeidung manueller Datenübertragung

Prozesseffizienz

- Gesteigerte Prozessautomatisierung

- Verbesserte interne Prozesse, wie zum Beispiel für Compliance und Genehmigungsverfahren

- Verbesserte externe Prozesse, beispielsweise im Vertrieb oder im Einkauf

IT-Projekte beschleunigen

- Wiederverwendung vorhandener Funktionen

- Redundante IT-Anwendungen verringern

- Schnellere Reaktion auf neue Anforderungen aus den Geschäftsbereichen

- Geringerer Wartungsaufwand

Entkopplung von Architektur-
Bestandteilen

Reduzierte Komplexität der
Architektur insgesamt

Schnellere Reaktionsfähigkeit der
IT auf neue Anforderungen

mehr
Flexibilität und Effizienz
(Kosten, Geschwindigkeit)
in der Bereitstellung und im
Betrieb von Funktionalität

Technologie neutral:
SoA-Services müssen mithilfe minimalen standardisierten Technologien nutzbar sein,
welche fast alle IT-Umgebungen mitbringen. Das hat zur Folge, dass die Aufrufmechanismen,
wie Protokolle, Beschreibungen und die Servicesuche/-entdeckung, weit
verbreitete und akzeptierte Standards nutzen, wie z.B. HTTP, SOAP und WSDL.
Locker verbunden:
Services der SoA dürfen keine Informationen, interne Strukturen oder Konventionen
erfordern und zwar weder auf der Nutzer- noch auf der Serviceseite.
Lokalitätstransparent:
SoA-Services sollen ihre Definitions- und Lokalitätsinformation, der Ort an dem der
Service gespeichert ist, in einem Verzeichnisdienst wie zum Beispiel UDDI gespeichert
haben. Das ermöglicht dem Servicenutzer den Service zu lokalisieren und aufzurufen
unabhängig von dessen wirklichem Speicherort.
  unabhängig -> autonome Software
(= black box)

aufrufbaren -> intern
 auf anderem
Rechner
 extern
 nachrichtenbasiert
 lose
gekoppelt

Geschäftsprozess
steht im Vordergrund

Workflow Steuerung

Der entscheidende Vorteil der serviceorientierten Architektur liegt darin, dass SoA
die Implementierung eines Service von dessen Schnittstelle trennt. Das heißt es wird
das was vom wie getrennt. Der Servicenutzer braucht nicht zu wissen wie der
Service funktioniert und implementiert ist, für ihn ist nur interessant, dass er ihm zur
Verfügung steht und dass er ihm die Serviceleistung liefert die er benötigt. 
 man den Service als eine
isolierte Einheit einer Unternehmensfunktion ansehen kann. Diese sind nach einer
gemeinsamen Vorschrift locker miteinander zu einem Standard Kommunikations-
Framework, einer serviceorientierten Architektur, verbunden. Durch die Unabhängigkeit,
welche die Services in diesem Framework haben und die entkapselte Programmierlogik,
die sie mitbringen, sind sie nicht an irgendeine Plattform oder Technologie
gebunden.

Eine serviceorientierte Architektur ist im wesentlichen eine Sammlung von Services.
Diese kommunizieren miteinander indem sie sich Daten schicken oder gemeinsam eine Aktivität koordinieren. Dazu wird ein Mechanismus benötigt, mit dem Services
zusammengefügt werden können.

Grundlegend neu am SOA Ansatz ist die Idee, den Geschäftsprozess in den Vordergrund zu stellen. Im Gegensatz zur eher monolithischen IT-Anwendung, die unterschiedliche Funktionalitäten kapseln, ermöglicht SOA die Verfügbarkeit und Vernetzung unterschiedlicher Dienste von unterschiedlichen Anbietern im gesamten Unternehmen
  Die bekannteste Implementierung einer serviceorientierten Architektur sind Webservices,
da diese mit einem Minimum an standardisierten Protokollen auskommen.
Der Datenaustausch wird, nach [9], meist mit Hilfe von SOAP, einem XML basierten
Datenaustauschprotokoll, über das Transportprotokoll HTTP durchgeführt. Dabei ist
es bemerkenswert, wie die verschiedensten Protokolle zusammenarbeiten. SOAP beispielsweise
ist unabhängig vom Transportprotokoll definiert und kann daher auch über
andere Transportprotokolle wie HTTPS, FTP oder SMTP arbeiten. Alternativ zu
SOAP kann der Datenaustausch auch über XML-RPC erfolgen.
Im Folgenden werden die Kernentitäten des SoA-Paradigmas aufgeführt und beschrieben
welcher Teil eines Webservices für diese Aufgabe zuständig ist:
    
  
  "Web Services" beschreiben sich selbst über eine so genannte WSDL Datei. Diese Datei enthält eine Dokumentation der verfügbaren Dienste und Anleitungen und erklärt, wie diese Dienste angesprochen werden können. Der Web Service meldet sich bei einem Service Broker an. Den Broker kann man sich als Verzeichnisdienst, als "Gelbe Seiten" der Dienste vorstellen. Ein Anwender kann in diesem Verzeichnisdienst einen geeigneten Dienst suchen und die WSDL Beschreibung anfordern. Über ein von W3C definiertes Protokoll (SOAP) können Anwender und Anbieter miteinander kommunizieren.
  die Web Service Description Language. Sie definiert, was für Nachrichten mit einem Web-Service auszutauschen und welche seiner Operationen auszuführen sind. Außerdem beschreibt WSDL, wie die fachlichen Nachrichten als technische Soap-Messages aufgebaut sind und wo im Internet ein Server zur Nutzung des Service bereitgestellt ist.

Definition: Service
.. Ein Service ist eine definierte Leistung, einer im Systemzusammenhang definierten
fachlichen Funktion, die von Anwendungsbausteinen erbracht und genutzt wird.
.. Die Serviceschnittstelle (Signatur und funktionale Spezifikation) ist ein Vertrag
zwischen Nutzer und Anbieter.
.. Die Serviceimplementierung ist nicht Teil dieser Abstimmung, bleibt in der
Verantwortung des Service-Anbieters und ist unter Einhaltung des Schnittstellen-
Vertrages austauschbar.   

Steigende Anforderungen
an Integrationsprojekte
.. Steigende Zahl der
Anwendungen im
Unternehmen
.. Steigende Komplexität
der Anwendungen
.. Zunehmende
Schnittstellenkomplexität
.. Zunehmende
Technologievielfalt
.. Zunehmende
Integrationstiefe


Allerdings kann mithilfe der Schnittstellentechnologie Webservices eine SOA umgesetzt werden.Ein Dienst ist entsprechend eine logische Einheit von oft hoher Komplexität  eine Anwendung, Hardware oder eine Kombination aus beiden, die zusätzlich noch menschliche Leistungen umfassen kann.
Die SOA koppelt derartige Dienste lose: Sie werden nur bei Bedarf gebunden. Ist die Aufgabe erledigt, wird die Bindung wieder aufgehoben.


%Computerwoche










%Java MagazinSOA ist die Abkürzung für Service-

Die Systemlandschaft von Unternehmen ist oftmals sehr heterogen: SAP-Systeme, Nicht-SAP-Systeme, Eigenentwicklungen und Systeme von externen Partnern und Lieferanten müssen untereinander über Schnittstellen kommunizieren. Verschiedene Systeme arbeiten jedoch mit unterschiedlichen Programmiersprachen. Schnittstellen müssen deshalb erst aufwendig erstellt und später gewartet und gepflegt werden. An dieser Stelle setzt SOA an. SOA nutzt standardisierte WebServices als Schnittstellentechnik.

Ein Prozess, z.B. die Anlegung eines Kundenauftrages, setzt sich aus vielen einzelnen Services zusammen. Ein Service ist z.B. der Aufruf eines Kundenstammes. Der Auftrag wird z.B. in einem SAP-System eingegeben, der Kundenstamm liegt in einem Nicht-SAP CRM-System, zusätzlich wird der Kundenstamm für die Rechnungsverbuchung benötigt.  Da die Systemlandschaften der renommierten Hersteller WebServices unterstützen, entfällt mit SOA die zeit- und kostenaufwändige Anpassung von Schnittstellen zwischen den Programmen.

SOA ist zudem flexibler. Ohne SOA werden bei einer Änderung der Geschäftsprozesse einzelne Module oftmals um zusätzliche Funktionen erweitert. Die Komplexität steigt. SOA dagegen benutzt die einzelnen Services wie einen Baukasten, einzelnen Services können beliebig zu genau dem Prozess kombiniert werden, wie es das Geschäftsmodell des Unternehmens erfordert, egal in welchem System der Service vorhanden ist.




%---Barry & Associates Inc, Service-oriented architecture (SOA) definition
Definition der SoA [14]:
A service-oriented architecture is essentially a collection of services. These services
communicate with each other. The communication can involve either simple data
passing or it could involve two or more services coordinating some activity. Some
means of connecting services to each other is needed.
Serviceorientierte Architektur ist zwar ein recht neuer Begriff in der
Softwareentwicklung, aber der Begriff Service wird in der Softwareentwicklung
schon länger benutzt.
Sun definierte die SoA strenger, um Jini zu beschreiben. Jini ist ein System, um Services,
Geräte und Anwendungen in einer dynamischen Umgebung zu vernetzen [6].
In letzter Zeit gibt es neue Bemühungen SoA umzustrukturieren, um den Gedanken
von Webservices, in der serviceorientierten Struktur, aufzugreifen. Die folgende Abbildung
zeigt, wie Technologien benutzt werden können, um die serviceorientierte
Architektur zu implementieren.


Eine SoA ist ein Softwareentwurfsmodell mit dem elementaren Konzept der Abkapselung
von Anwendungslogik innerhalb der Services. Die Services können über ein
vereinbartes Kommunikationsprotokoll miteinander kommunizieren.
Da die Services serviceorientiert sind, gibt es keine Trennung zwischen Client und
Server. In der SoA gibt es nur noch Services, die unabhängig von ihrer Umwelt sind
und wenn, dann nur in einer lockeren Beziehung zueinander stehen. Versucht man die
serviceorientierte Architektur mit der Client-Server Architektur zu verstehen, dann
würde die Abbildung (Fig. 3) die Interaktion zweier Services am besten wiedergeben.


Eine SOA ist eine Methode zur Konzeption
und Realisierung von Unternehmensanwendungen, die es verschiedenen
Applikationen unabhängig vom zugrunde liegenden Betriebssystem und
der gewählten Programmiersprache erlaubt, Daten auszutauschen und zu
verarbeiten. Zur Realisierung werden vollständige Anwendungen, oder Teile
daraus, als Dienste angeboten, die ohne Codierungsaufwände genutzt werden
können. (vgl. Jec03)
Komplexere Geschäftsprozesse werden durch die Kombination mehrerer
Services realisiert. Die Programmlogik wird übere diverse, voneinander unabhängige
Dienste verteilt und ist nicht in einem einzigen Programm implementiert.


Zusammenfassung

Business Process Execution Language (BPEL) hat sich als ein Quasi-Standard für die Komposition mehrerer Web Services zu einem Geschäftsprozess etabliert. Trotz der breiten Akzeptanz dieser Sprache existieren noch sehr wenige Werkzeuge, die das Testen von BPEL-Prozessen unterstützen. Mit \textit{BPELUnit} wurde ein Framework entwickelt, der das strukturierte Testen einer BPEL-Komposition in Isolation (unabhängig von zusammengestellten Diensten) ermöglicht. Die Testabdeckungsanalyse, als Mittel zur Qualitätskontrolle von Tests, wird durch das Framework nicht durchgeführt. Genau an dieser Stelle knüpft diese Masterarbeit an.  

Es wird in der Arbeit untersucht, inwiefern die bekannten Testabdeckungsmetriken, die in konventionellen Programmiersprachen zur Bewertung der Tests eingesetzt werden, auf die BPEL-Sprache übertragen werden können. Außerdem werden neue für BPEL sinnvolle Metriken ausgearbeitet. Anschließend soll ein Konzept für die Integration dieser Metriken in das BPELUnit-Framework erarbeitet und implementiert werden.



%ComputerWoche

Die letzten beiden BPEL-Elemente <flow> und <link> werden an dieser Stelle ausführlicher
behandelt, da diese das graph-ähnliche Verhalten des Kontrollflusses beschreiben können.
Flow - Die strukturierte <flow>-Aktivität wird für die parallele Ausführung elementarer Aktivitä-
ten benutzt. Des Weiteren kann dieses Element auch für die Synchronisation verschiedener Zweige in
einem BPEL-Prozess verwendet werden. Wichtig dabei ist, dass alle die zu konkurrierenden und zu
synchronisierenden Aktivitäten in einem <flow>-Element definiert werden. Die Reihenfolge der Ausf
ührung der enthaltenen elementaren und der strukturierten Aktivitäten wird durch Links eindeutig
festgelegt.

 Das Schlüsselwort activity stellt symbolisch die erlaubte Menge einzelner
Aktivitäten in einem Geschäftsprozess dar. Es wird nachfolgend im Zusammenhang mit elementaren
und strukturierten Aktivitäten verwendet. Es beschreibt, was ein Prozess macht.
Für die Transformation spielt das Element <activity/> eine besondere Rolle. Hier werden
elementare Aktivitäten, die in dem EPK-Diagramm der Funktion entsprechen sollen, und strukturierte
Aktivitäten, die aus dem Kontrollfluss eines EPK-Diagramms abgeleitet werden sollen,
definiert.
Im Folgenden werden die wichtigsten Elemente des BPEL-Schemas näher untersucht. Die dazu
entsprechenden Listings, die die Definition von BPEL-Instanzen näher beschreiben, können in Anhang
B nachgelesen werden. Zur vollständigen Definition der BPEL-Elemente wird auf die Spezifikation
[ACD+03] verwiesen.
PartnerLink - identifiziert einen Partner-Web Service, der mit dem betrachteten Business-Prozess
Nachrichten austauscht. Über die Rollen myRole und partnerRole wird der Nachrichtenaustausch
spezifiziert. Es ist ein bilateraler Nachrichtenaustausch zwischen den betrachteten Partnern, wenn
beide Attribute myRole und partnerRole definiert sind. Wird dagegen nur eine Rolle definiert, so
handelt es sich dabei um eine asynchrone Nachricht. Die partnerLinks spielen mit den elementaren
Aktivitäten Receive, Reply und Invoke eine bedeutende Rolle, die Web Services auslösen können.
Partner - In dem Element <partners> werden die einzelnen Partner mit ihren dazu gehörigen
<partnerLinks> gekapselt. In diesem Fall bedeutet es, dass einzelne oder mehrere Web Services,
die über die <partnerLinks> verbunden werden, hier zusammengefasst werden können.
Variables - Wenn Web Services ausgeführt und zwischen diesen Nachrichten oder Daten ausgetauscht
werden, dann müssen diese in Variablen gehalten werden. Eine Variable in einem BPELProzess
ist an ihrem Namen und dem verwendeten Datentyp aus dem XML-Schema eindeutig identi
fizierbar.




 
Invoke - Mit <invoke> wird ein Geschäftsprozess des Partners aktiviert, indem eine Nachricht
zum Partner-Web Service gesendet wird. Ein Invoke kann eine Operation in nur eine (request) oder
bidirektionale Richtung (request-response) auf dem <portType> eines Partners auslösen. Bei einer
request-Operation handelt es sich um einen asynchronen und bei der request/response-Operation
um einen synchronen Aufruf. Die entsprechende Operation wird in der WSDL-Datei des Partners
definiert. Beim asynchronen Auslösen des Prozesses wird nur die inputVariable benutzt. Beim
synchronen Auslösen wird zusätzlich die outputVariable verwendet.
Receive - veranlasst den Prozess zu warten, bis eine passende Nachricht vom Partner-Service
ankommt. In einem solchen Fall kann der Prozess nicht fortfahren oder sich beenden, bis die Nachricht
eintritt. <receive> führt beim <partnerLink> an einem <portType> eine <operation> aus
und bindet die erwartete Nachricht an die entsprechende <variable>.
Reply - veranlasst den Prozess, eine Beantwortung auf die Partner-Nachricht zu senden. Der
Prozess sendet an dem entsprechenden <partnerLink> über den dazu gehörigen <portType> eine
bestimmte <operation>. In dem Fall, dass der Partner nicht empfangen kann, wird ein <fault-
Name> zur Fehlerbehandlung definiert.
Empty - Das <empty>-Element führt keine Aktivität durch. Diese Aktivität kann aufgrund ihrer
Eigenschaft in beliebigen Kontexten verwendet werden. 
Assign - Beim Nachrichtenaustausch ist es erforderlich, dass zwischen den verschiedenen Aktivit
äten Manipulationen an Variablen vorgenommen werden. Eine solche Manipulation der Variablen
in BPEL erfolgt über die <assign>-Aktivität. Diese kopiert Daten von der Quelle (from) zum Ziel
(to). Eine Ausführliche Behandlung dieser Aktivität wird in Abschnitt 4.5 und 5.4.2 gegeben.
Link - Die oben vorgestellten Kontrollstrukturen erlauben, viele typische Arbeitsabläufe zu modellieren.
Es ist jedoch nicht möglich, noch weitere Sequenzen zu definieren, wenn die Aktivitä-
ten innerhalb dieser Sequenzen einer bestimmten Reihenfolge unterliegen. Die verwendete XMLDatenstruktur,
die nur hierarchische Modellierung erlaubt, bringt das auf XML-basierte Konzept schnell an seine Grenzen. Um dieses Problem zu umgehen, wurden hierfür die Links in dem <flow>-
Block eingeführt. Die Links erlauben bei der Modellierung Verknüpfungen zwischen einzelnen Aktivit
äten herzustellen. Somit stellt ein <flow>-Element mit den dazugehörigen <links> graphentheoretisch
nichts anderes als eine Kante zwischen zwei Aktivitäten dar.
Jeder Link wird über seinen Namen in der <links>-Definition eindeutig identifiziert. Um die
Links benutzen zu können, müssen hierfür in jeder Aktivität, die mit den Links verbunden werden
soll, zwei weitere optionale Elemente <source> und <target> definiert werden. Der Kontrollfluss
verläuft von der Aktivität mit dem <source>-Element zu der Aktivität mit dem <target>-Element.
Anhand der Definition der linkNames wird die auszuführende Reihenfolge identifiziert. Somit können
die Aktivitäten beliebig viele <source>- oder <target>-Einträge2 enthalten, wobei man beachten
sollte, dass die Definitionen eindeutig sind und nicht doppelt vorkommen dürfen.
Beim Synchronisieren der Links an der Target-Aktivität muss das Attribut joinCondition, welches
als optionale Attribut in allen Aktivitäten belegt werden kann, gesetzt werden. Wenn das Attribut
joinCondition nicht gesetzt ist, so ist der Default-Wert vom Linkstatus aller eingehender Links der
betrachteten Aktivität eine logische Disjunktion (logical or ). Der Status des Links kann mit get-
LinkStatus('linkName') abgefragt werden. Für die richtige Verwendung der Links sorgt die in BPEL
eingeführte Dead-Path-Elemination (DPE). Auf die ausführlichere Definition der Link-Semantik und
der DPE wird in diesem Zusammenhang auf die BPEL-Spezifikation [ACD+03] verwiesen.
Die Links ermöglichen, die hierarchische Struktur der XML-Struktur zu sprengen und erlauben
somit zwei Aktivitäten auszuführen, die sich in unterschiedlichen Verschachtelungsebenen der XMLDatenstruktur
befinden. Dieser Zusammenhang ist in der nächsten Abbildung zu erkennen. Ein solcher
Fall wäre mit anderen strukturierten Aktivitäten ohne die Links in BPEL nicht modellierbar.

AktivitÄaten
Im Zentrum der Modellierung von GeschÄaftsprozessen stehen die AktivitÄaten und ihre kau-
salen ZusammenhÄange. In BPEL4WS gibt es zwei Sorten von AktivitÄaten: Basic Activities
und Structured Activities.
Die einfachen AktivitÄaten reprÄasentieren atomare Einheiten und lassen sich erneut in
zwei Gruppen teilen: FÄur die Kommunikation mit einem anderen Web Service sind die
AktivitÄaten invoke, receive und reply zustÄandig. Mit invoke kann ein anderer Web Service
aufgerufen werden, d. h. es wird eine Nachricht an diesen gesendet und gleich oder spÄater
eine Antwort erwartet. Mit receive wird ein Aufruf (eine Nachricht) von einem anderen Web
Service entgegen genommen und mit reply dieser beantwortet.
Die zweite Gruppe der einfachen AktivitÄaten reprÄasentieren interne Schritte: assign ist
eine Wertzuweisung, wait ist ein Timer und empty ist eine leere AktivitÄat. Teilweise steuern
sie auch den weiteren Prozessverlauf: terminate bricht den Prozess ab, throw wirft einen
Fehler und compensate veranlasst die RÄucksetzung eines Teils des Prozesses.
Neben den einfachen AktivitÄaten gibt es in BPEL4WS auch fÄunf Klassen strukturierter
AktivitÄaten. Mit diesen AktivitÄaten wird der Kontroll°uss abgebildet: Die einfachste ist se-
quence, diese AktivitÄat de¯niert die sequentielle Ordnung einer Menge anderer AktivitÄaten.
Die alternative Auswahl zwischen AktivitÄaten ist mit Hilfe von pick und switch mÄoglich, bei
pick entscheidet eine Nachricht von au¼en, bei switch wird durch die Auswertung von Daten
eine Entscheidung getro®en. Mit der AktivitÄat while ist es mÄoglich, zyklisches Verhalten
zu de¯nieren. Letztlich dient die AktivitÄat °ow dazu, eine unabhÄangige Menge von Akti-
vitÄaten zu spezi¯zieren. Innerhalb von °ow kÄonnen die AktivitÄaten durch zusÄatzliche links
untereinander synchronisiert werden. Jede der strukturierten AktivitÄaten enthÄalt ihrerseits
mindestens eine AktivitÄat. Auf diese Weise kÄonnen durch Schachtelung beliebig komplexe
Kontroll°uss-Beziehungen gebildet werden.
Ein Sonderrolle spielt die AktivitÄat scope.

Das Kernkonzept von BPEL ist die Aktivität. Ein BPEL-Prozess ist genau eine Aktivität, in
der weitere Aktivitäten enthalten sind. BPEL unterscheidet dabei zwei Arten von Aktivitäten:
Basisaktivitäten und Strukturierte Aktivitäten.
Basisaktivitäten erfüllen die atomaren Aufgaben des Prozesses:
 Kommunikation:
 Empfang von Nachrichten, mit <receive>
 Beantwortung empfangener Nachrichten, mit <reply>
 Aufruf eines Web Service, mit <invoke>
 Datenmanipulation:
 Manipulation von Werten in Variablen, mit <assign>
Sonstige Basisaktivitäten:
Nichtstun, mit <empty>
 Warten, mit <wait>
 Signalisieren von Fehlern und Ausnahmen, mit <throw>
 Beenden der Prozessinstanz, mit <terminate>
 Kompensation von abgearbeiteten Aktivitäten, mit <compensate>

Basisaktivitäten werden mit Hilfe von Strukturierten Aktivitäten in eine Reihenfolge der Ausführung
gebracht:
 Sequentielle Anordnung von Aktivitäten, mit <sequence>
 Parallele Anordnung von Aktivitäten, mit <flow>
 Auswahl von Alternativen (basierend auf Daten), mit <switch>
 Auswahl von Alternativen (basierend auf Nachrichten oder zeitgesteuerten Ereignissen),
mit <pick>
 Definition von Schleifen, mit <while>

ktivitÄaten kÄonnen ineinander geschachtelt sein und bilden somit eine hierarchische Struk-
tur { einen AktivitÄaten-Baum. DieWurzel dieses Baumes ist der Prozess: Ein Prozess besitzt
genau eine AktivitÄat. Neben dieser AktivitÄat kann ein Prozess event handler, fault handler
und compensation handler besitzen, d. h. ein Prozess ist auch gleichzeitig ein scope.

WS-BPEL 2.0 bietet mit der neuen <forEach>-Aktivität ein weiteres Konstrukt zur wiederholten
Ausführung einer Scope-Aktivität.

Beim Start der <forEach>-Aktivität werden die Ausdrücke in den <startCounterValue>- und
<finalCounterValue>-Elementen einmalig ausgewertet und bleiben dann über die gesamte
Laufzeit der Aktivität konstant. Die dort spezifizierten Ausdrücke müssen ein xs:unsignedint
als Ergebnistyp haben, sonst wird der Fehler bpws:forEachCounterError geworfen. Sollte der
Wert von <startCounterValue> größer sein, als der von <finalCounterValue>, wird keine
Iteration durchgeführt.
Über das Attribut parallel kann gesteuert werden, ob der Schleifenkörper sequentiell oder
parallel abgearbeitet wird.

Im Fall von parallel=no wird die Schleife sequentiell abgearbeitet. Die eingebettete Scope-
Aktivität wird N+1 Mal (wobei N die Differenz von <finalCounterValue> und <startCounterValue>
ist) nach einander ausgeführt. Für jeden Durchlauf wird eine Variable vom Typ xs:unsignedint
kreiert, die dann mit dem aktuellen Zählerwert initialisiert wird. Der Bezeichner dieser Variable
wird über das Attribut counterName der <forEach>-Aktivität festgelegt. Im ersten Durchlauf
wird sie auf denWert von <startCounterValue> initialisiert und bei jedem weiteren Durchlauf
inkrementiert. Im letzten Durchlauf besitzt die Zählervariable denWert von <finalCounterValue>.
Die Zählervariable ist lokal für den eingebetteten Scope, kann also von diesem gelesen und geschrieben
werden. Nach einer Abarbeitung des Schleifenkörpers werden jedoch alle Änderungen
an dieser Variable verworfen.
Im Fall von parallel=yes wird die Schleife parallel abgearbeitet. Es wird eine implizite
Flow-Aktivität generiert, die N+1 Instanzen der eingebetteten Scope-Aktivität enthält. Für jede
dieser Instanzen wird eine Zählervariable (wie im sequentiellen Fall) kreiert, die eindeutig mit
einem Wert aus dem Intervall <startCounterValue> bis <finalCounterValue> initialisiert
wird.
Optional kann eine <forEach>-Aktivität ein <completionCondition>-Element enthalten.Wird
die in diesem Element spezifizierte Bedingung während der Abarbeitung erfüllt, so kann die
<forEach>-Aktivität vorzeitig beendet werden. Das <completionCondition>-Element enthält
das Element <branches>, in dem ein Integer-Ausdruck angegeben wird. Dieser wird beim Start
der <forEach>-Aktivität einmalig ausgewertet. Ist der Wert des Ausdrucks größer als die Anzahl
der Schleifendurchläufe (bzw. parallelen Instanzen), wird der Fehler bpws:invalidBranch-
Condition geworfen. Nach jeder Abarbeitung eines eingebetteten Scope wird die Anzahl der
abgearbeiteten Scopes mit dem Wert dieses Ausdrucks verglichen. Ist die Anzahl der abgearbeiteten
Scopes größer oder gleich dem Wert des Ausdrucks, gilt die Bedingung als erfüllt. Es
lassen sich also Bedingungen nach dem Muster mindestens M aus N 6 definieren.

Scope
Die Spezifikation von WS-BPEL 2.0 beschreibt das Verhalten von Scopes für den Fall der Initialisierung
und Beendigung.
Die Abarbeitung eines Prozesses bzw. Scopes beginnt mit der Initialisierung. Dabei werden
die Fault und Termination Handler, Partner Links, Correlation Sets und die Variablen instanziiert
und initialisiert. Die Partner Links müssen erstellt werden, bevor die im gleichen Scope
definierten Variablen initialisiert werden können. Die Scope-Initialisierung verläuft nach dem
Motto: alles oder nichts. Entweder alles wird erfolgreich initialisiert oder es wird der Fehler
bpws:scopeInitializationFailure geworfen, der vom umgebenden Scope behandelt werden muss.
Im Falle eines solchen Fehlers auf Prozessebene gilt der gesamte Prozess als faulted. Nachdem
die Initialisierung abgeschlossen ist, werden die erste innere Aktivität und die Event Handler des
Scope parallel instanziiert. Eine Ausnahme dazu stellen Scopes dar, die eine initial start activity
enthalten (d.h. die Instanziierung einer weiteren Prozessinstanz bewirken). In diesem Fall muss
zuerst die initial start activity beendet worden sein, bevor die Event Handler instanziiert werden
können.
Wird ein Scope vollständig abgearbeitet, müssen alle Interaktionen mitWeb Services, die abhängig
von innerhalb des Scope definierten Partner Links und messageExchange-Definitionen sind,
beendet sein. Bleiben Empfangsaktivitäten offen, die sich auf Partner Links oder messageExchange-
Definitionen des Scope beziehen, kann der Fehler bpws:missingReply geworfen werden.8
Ein Scope (bzw. Prozess) kann in WS-BPEL 2.0 das exitOnStandardFault-Attribut besitzen.
Falls der Wert dieses Attributs auf yes gesetzt ist, muss der Prozess sofort beendet werden
(äquivalent zum Erreichen der Aktivität <exit>), wenn ein anderer WS-BPEL Standardfehler
als bpws:joinFailure auftritt. IstWert des Attributs hingegen no, so kann der Prozess den Standardfehler
mittels eines Fault Handler behandeln. Der Standardwert des exitOnStandardFault-
Attributs ist no. Wird dieses Attribut von einer Scope-Aktivität nicht spezifiziert, so wird der
Wert vom umgebenden Scope bzw. Prozess geerbt.

Isolierte Scopes
Serialisierbare Scopes werden in WS-BPEL 2.0 als isolierte Scopes bezeichnet. Das Attribut
variableAccessSerializable heißt nun entsprechend isolated. Neu ist auch, dass ein als
isoliert markierter Scope weitere Scopes einbetten kann, die nicht als isoliert markiert sind.9 Der
Zugriff auf gemeinsam genutzte Variablen durch die so eingebetteten Scopes wird dann über den
isolierten Scope kontrolliert.
Beachte, dass die Isolation eines Variablenzugriffs nicht zu einem internen Deadlock in einem
BPEL-Prozess führen kann. Der Grund dafür liegt darin, dass ein isolierter Scope nicht eher
gestartet wird, als bis er exklusiven Zugriff auf alle vom ihm benötigten nicht-lokalen Variablen
hat.

Event Handler
Event Handler führen in WS-BPEL 2.0 grundsätzlich nur noch Scope-Aktivitäten aus, um eine
saubere Scope-Snapshot- und Kompensationssemantik zu gewährleisten. Dies ist natürlich
keine Einschränkung, da die Scope-Aktivität beliebige weitere Aktivitäten enthalten kann. Tritt
während der Abarbeitung eines Event Handler ein Fehler auf, wird dieser also zuerst vom Fault
Handler der eingebetteten Scope-Aktivität behandelt bzw. von ihm an den umgebenden Scope
weiter gereicht.
Sowohl von <onEvent>- als auch von <onAlarm>-Event-Handler können zu einem Zeitpunkt
mehrere aktive Instanzen existieren. Jede Instanz erhält daher eine private Kopie der im eingebetteten
Scope deklarierten Daten und Ressourcen (inkl. Links und Partner Links), um Zugriffskonflikte
zu verhindern.

Fault Handler
Die WS-BPEL 2.0 Spezifikation beschreibt die optional zu einem Fehlernamen assoziierten Fehlerdaten
weitaus konkreter, als dies bisher der Fall war.
Fehlerdaten sind WSDL-Nachrichtentypen oder XML-Schema-Elemente. Jeder <catch>-Zweig,
der einen faultName spezifiziert kann nur Fehler eines einziges Typs behandeln. Wenn die
zu behandelnden Fehlerdaten von einem WSDL-Nachrichtentyp sind, dann muss dieser mittels
des (neuen optionalen) faultMessageTyp-Attributs spezifiziert sein.Wenn die Fehlerdaten eine
XML-Element-Definition sind, dann muss diese mittels des (neuen optionalen) faultElement-
Attributs spezifiziert sein.
Da das Attribut faultName optional ist, kann es vorkommen, dass eine spezifizierte faultVariable
keinem konkreten Typ zugeordnet werden kann. Um dies zu verhindern, muss bei der Spezifikation
des faultVariable-Attributs stets auch entweder ein faultMessageType- oder ein
faultElement-Attribut mit angegeben werden. Zudem dürfen sowohl das faultMessageTypeals
auch das faultElement-Attribut nie ohne ein begleitendes faultVariable-Attribut angegeben
werden.
Für die Behandlung eines Fehlers können mehrere Fault Handler zur Auswahl stehen. Die Regeln,
nach denen ein Fault Handler zur Fehlerbehandlung ausgewählt wird, wurden in Anbetracht
der erweiterten Möglichkeiten von WS-BPEL 2.0 entsprechend angepasst.1

Termination Handler
Scopes besitzen die Möglichkeit, auf den Ablauf einer erzwungenen Terminierung Einfluss zu
nehmen. Was in BPEL4WS 1.1 als Forced-Termination-Zweig des Fault Handler definiert wurde,
wird in WS-BPEL 2.0 innerhalb des Scope als Termination Handler definiert. Dieser kann
die selben Aktivitäten verwenden, die auch in einem Fault Handler verwendet werden können.
Es wird also nicht mehr der Fehler bpws:forcedTermination geworfen, auf den dann im Fault
Handler reagiert werden kann, sondern im Falle einer erzwungenen Terminierung wird nach der
Beendigung aller laufenden Aktivitäten des Scope der Termination Handler ausgeführt. Ist kein
Termination Handler definiert, wird ein Standard-Termination-Handler aktiviert. Dieser kompensiert
alle erfolgreich beendeten eingebetteten Scopes in der standardmäßigen Kompensationsreihenfolge
(siehe 3.10.1). Er verhält sich also wie der Standard-Fault-Handler.

Compensation Handler
Der aktuelle Zustand des Prozesses setzt sich aus den aktuellen Zuständen aller gestarteten Scopes
zusammen. Dies beinhaltet Scopes die erfolgreich abgearbeitet wurden, deren Compensation
Handler aber noch nicht aufgerufen wurde. Der aktuelle Zustand eines erfolgreich abgearbeiteten
Scope entspricht dessen Zustand zum Zeitpunkt der Beendigung der Abarbeitung. Ein Scope
kann, möglicherweise als Teil eines Schleifendurchlaufs, mehrfach ausgeführt worden sein. In
diesem Fall enthält der aktuelle Zustand des Prozesses den Zustand einer jeder erfolgreichen
(nicht kompensierten) Ausführung eines solchen Scope. Dieser gesicherte Zustand eines erfolgreich
abgearbeiteten unkompensierten Scope wird als Scope-Snapshot bezeichnet.
Compensation Handler nutzen in WS-BPEL 2.0 immer den aktuellen Zustand des Scope, d.h.
den Zustand des Scope, in dem sie definiert wurden und allen darin eingebetteten Scopes. Dies
umfasst die dort deklarierten Variablen, Partner Links und Correlation Sets. Sie sind in der Lage,
dieWerte all dieser Variablen zu lesen und zu setzen. Andere Teile des Prozesses können die
Veränderung an gemeinsam genutzten Variablen sehen, genauso wie die Compensation Handler
Veränderungen sehen können, die durch andere Teile des Prozesses an gemeinsam genutzten
Variablen vorgenommen werden. Dies gilt auch für den Fall einer parallelen Abarbeitung. Um
Konflikte im Falle von erwarteter gleichzeitiger Abarbeitung zu verhindern, müssen Compensation
Handler isolierte Scopes (siehe 3.6.1) verwenden, wenn sie in den Zustand eines eingebetteten
Scope eingreifen.
Wie auch in BPEL4WS 1.1 steht ein Compensation Handler nur für Scopes zur Verfügung, die
ordnungsgemäß abgearbeitet wurden. Wird ein Compensation Handler wiederholt aufgerufen,
wird dies in WS-BPEL 2.0 ignoriert.11 Dabei spielt es keine Rolle, ob es sich um einen aktivierten
oder deaktivierten Compensation Handler handelt.
Die aus BPEL4WS 1.1 bekannte Aktivität <compensate> wurde in zwei Aktivitäten zur Kompensation
aufgeteilt: <compensate>, zur Kompensation aller eingebetteten Scopes in der standardmäßigen
Kompensationsreihenfolge (siehe 3.10.1) und <compensateScope> zur Kompensation
eines speziellen Scope. Ist der zu kompensierende Scope in eine Schleife oder einen Event
Handler eingebettet, müssen alle Iterationen der Schleife bzw. alle verarbeiteten Ereignisse des
Event Handler kompensiert werden. Die für eine solche Aktivität im Laufe der Abarbeitung
aktivierten Compensation Handler werden dabei als eine Einheit betrachtet, die als Compensation
Handler Instance Group bezeichnet wird. Im Falle eines Aufrufs von <compensate>,
umfasst diese Compensation Handler Instance Group alle Compensation-Handler-Instanzen der
erfolgreich abgearbeiteten Scopes, die in der Aktivität eingebettet sind. Im Falle eines Aufrufs
von <compensateScope>, jedoch nur die Compensation-Handler-Instanzen des spezifizierten
Ziel-Scope. Sollte während der Abarbeitung einer dieser Compensation-Handler-Instanzen ein
unbehandelter Fehler auftreten, wird die gesamte Compensation Handler Instance Group beendet
und alle enthaltenen Compensation Handler werden deaktiviert.
Standardmäßige Kompensationsreihenfolge
Die Spezifikation von WS-BPEL 2.0 beschreibt zwei Regeln, die für eine standardmäßige Kompensationsreihenfolge
gelten müssen. Um diese Regeln zu konkretisieren, werden formal einige
Begriffe definiert.12 Wir wollen uns jedoch hier nur auf eine informelle Wiedergabe dieser Regeln
beschränken:
1. Die Kompensation muss sich nach der Reihenfolge der Abarbeitung der zu kompensierenden
Scopes richten, soweit diese durch die Prozessdefinition vorgegeben ist.
Prozesse, in denen es zu Zyklen durch Links kommen kann, sind nicht gestattet, d.h. wenn
von einem Scope A ein Link in einen anderen Scope B führt, darf von Scope B kein Link
in den Scope A zurückführen.
Für den Fall von nebenläufig abgearbeiteten Scopes, die keine Kontrollflussabhängigkeiten durch
Links aufweisen, wird durch diese Regeln keine konkrete Kompensationsreihenfolge festgelegt.
Sie können also sowohl nebenläufig, als auch in strikter umgekehrter Reihenfolge ihrer Abarbeitung
nach einander kompensiert werden.
Kompensation und isolierte Scopes
Compensation Handler eines isolierten Scope werden, anders als entsprechende Fault Handler,
nicht innerhalb dessen isolierter Umgebung ausgeführt. Auch können diese Compensation
Handler nicht selbst isolierte Scopes verwenden, da isolierte Scopes nicht in einander geschachtelt
werden dürfen. Dies wirft jedoch Fragen in Bezug auf die Isolationssemantik der Compensation
Handler von in isolierten Scopes eingebetteten Scopes auf. Wie sieht deren Umgebung
im Falle eines Aufrufs durch einen Fault Handler (ausgeführt innerhalb der isolierten Umgebung
des umgebenden Scope) bzw. im Falle eines Aufrufs durch einen Compensation Handler
(ausgeführt außerhalb der isolierten Umgebung des umgebenden Scope) aus?
Um konsistentes Verhalten sicher zu stellen, verlangt die Spezifikation von WS-BPEL 2.0 das
Compensation Handler innerhalb eines isolierten Scope daher selbst implizit isoliertes Verhalten
zeigen, obwohl dies eine separate isolierte Umgebung erfordert.

Im Zentrum der Modellierung von GeschÄaftsprozessen stehen die AktivitÄaten und ihre kau-
salen ZusammenhÄange. In BPEL4WS gibt es zwei Sorten von AktivitÄaten: Basic Activities
und Structured Activities.
Die einfachen AktivitÄaten reprÄasentieren atomare Einheiten und lassen sich erneut in
zwei Gruppen teilen: FÄur die Kommunikation mit einem anderen Web Service sind die
AktivitÄaten invoke, receive und reply zustÄandig. Mit invoke kann ein anderer Web Service
aufgerufen werden, d. h. es wird eine Nachricht an diesen gesendet und gleich oder spÄater
eine Antwort erwartet. Mit receive wird ein Aufruf (eine Nachricht) von einem anderen Web
Service entgegen genommen und mit reply dieser beantwortet.
Die zweite Gruppe der einfachen AktivitÄaten reprÄasentieren interne Schritte: assign ist
eine Wertzuweisung, wait ist ein Timer und empty ist eine leere AktivitÄat. Teilweise steuern
sie auch den weiteren Prozessverlauf: terminate bricht den Prozess ab, throw wirft einen
Fehler und compensate veranlasst die RÄucksetzung eines Teils des Prozesses.
Neben den einfachen AktivitÄaten gibt es in BPEL4WS auch fÄunf Klassen strukturierter
AktivitÄaten. Mit diesen AktivitÄaten wird der Kontroll°uss abgebildet: Die einfachste ist se-
quence, diese AktivitÄat de¯niert die sequentielle Ordnung einer Menge anderer AktivitÄaten.
Die alternative Auswahl zwischen AktivitÄaten ist mit Hilfe von pick und switch mÄoglich, bei
pick entscheidet eine Nachricht von au¼en, bei switch wird durch die Auswertung von Daten
eine Entscheidung getro®en. Mit der AktivitÄat while ist es mÄoglich, zyklisches Verhalten
zu de¯nieren. Letztlich dient die AktivitÄat °ow dazu, eine unabhÄangige Menge von Akti-
vitÄaten zu spezi¯zieren. Innerhalb von °ow kÄonnen die AktivitÄaten durch zusÄatzliche links
untereinander synchronisiert werden. Jede der strukturierten AktivitÄaten enthÄalt ihrerseits
mindestens eine AktivitÄat. Auf diese Weise kÄonnen durch Schachtelung beliebig komplexe
Kontroll°uss-Beziehungen gebildet werden.
Ein Sonderrolle spielt die AktivitÄat scope.
ÄU
b
e
r
w
a
c
h
t
e
A
k
t
i
v
i
t
Äa
t
e
n
In BPEL4WS ist es mÄoglich, eine einzelne AktivitÄat unter besondere Beobachtung zu stel-
len, d. h. auftretende Fehler abzufangen, auf externe Ereignisse zu reagieren und ggf. die
AktivitÄat nach erfolgreicher AusfÄuhrung zu kompensieren, wenn es die Äau¼eren UmstÄan-
de verlangen. Zu diesem Zweck gibt es das Konzept des scopes als Aggregation aus event
handler, fault handler, compensation handler und einer Äuberwachten AktivitÄat. Auf der
einen Seite kann die Äuberwachte AktivitÄat wiederum strukturiert sein, so dass der scope
eine Menge von AktivitÄaten Äuberwachen kann. Auf anderen Seite kann der scope selbst als
eine AktivitÄat aufgefasst werden und damit in einer strukturierten AktivitÄat vorkommen.
Prozesse
AktivitÄaten kÄonnen ineinander geschachtelt sein und bilden somit eine hierarchische Struk-
tur { einen AktivitÄaten-Baum. DieWurzel dieses Baumes ist der Prozess: Ein Prozess besitzt
genau eine AktivitÄat. Neben dieser AktivitÄat kann ein Prozess event handler, fault handler
und compensation handler besitzen, d. h. ein Prozess ist auch gleichzeitig ein scope.
In BPEL4WS gehÄort zu einem Web Service genau ein Prozess. Es ist mÄoglich, diesen Pro-
zess prÄazise und vollstÄandig zu modellieren. Auf diese Weise gelangt man zu einem direkt
ausfÄuhrbaren Prozessmodell (= Executable Process). DarÄuber hinaus gestattet BPEL4WS
eine abstrakte Spezi¯kation des Verhaltens (= Business Protocol). Die abstrakte Spezi-
¯kation ist ein wesentlicher Teil der verÄo®entlichten Beschreibung des Web Service. Ein
potentieller Anwender entscheidet aufgrund dieser Spezi¯kation, ob der vorliegende Web
Service mit seiner Komponente kompatibel ist. Im Rahmen dieser Arbeit werden wir die
KompatibilitÄat zweier Web Services de¯nieren (siehe Abschnitt 3.1.4).
Die De¯nition der Kommunikation innerhalb des Prozesses stÄutzt sich auf die De¯nition
der Schnittstelle des Web Service mit WSDL ab.
Kommunikation
Ein Web Service ist ein o®enes System, dass mit anderen Komponenten (o. B. d. A. eben-
falls Web Services) Äuber Nachrichtenaustausch kommuniziert. Jede Nachricht ist ein XML-
Dokument, wobei die Typ der Dokumente bereits im WSDL-Modell des Web Service de¯-
niert werden. Als konsequente WeiterfÄuhrung verwendet BPEL4WS fÄur interne Datenstruk-
turen (variables) ebenfalls XML-Dokumente.
Die Schnittstelle fÄur die Kommunikation wird in WSDL de¯niert: Eine Nachrichten ist
ein XML-Dokument, das Senden und empfangen einer Nachricht (mit oder ohne Feedback)hei¼t Operation. Eine Menge von Operationen wird zu einem Porttype zusammengefasst.
Jeder Web Service bietet eine Menge von Porttypen an.
Die Kommunikation Äuber einen Porttypen kann man von zwei Seiten aus betrachten:
Auf der einen Seite gibt es den Web Service, der diesen Porttypen anbietet und auf der
anderen Seite gibt es einen Web Service, der diesen Porttypen von au¼en benutzt. Deshalb
wird in BPEL4WS die Verbindung zwischen den Operationen eines Porttypen und den
AktivitÄaten im Prozess durch PartnerLinks abgebildet: Die AktivitÄat receive und reply
implementieren eine Operation an der Schnittstelle dieses Web Service und stellen damit
einem anderem Web Service FunktionalitÄat zur VerfÄugung, die AktivitÄat invoke spezi¯ziert
eine Operation an der Schnittstelle eines anderen Web Service und benutzt damit dessen
FunktionalitÄat. Da ein anderer Web Service (d. h. ein Partner) in einem BPEL4WS-Modell
sowohl FunktionalitÄat anbieten als auch benutzen kann, wird ein Partner durch eine Menge
von PartnerLinks spezi¯ziert.
PEL4WS (kurz BPEL) unterscheidet zwischen ausführbaren und abstrakten Prozessen, wobei
die Unterscheidung für diese Arbeit irrelevant ist. Ein BPEL4WS Prozess selbst kann als
ein Ablaufdiagramm angesehen werden, wobei jeder Knoten eine Aktivität darstellt. Hierbei
wird zwischen primitiven und strukturierten Aktivitäten unterschieden. Die primitiven Aktivitäten
ermöglichen es: Operationen auf anderen Web Services aufzurufen (invoke), auf
Nachrichten von externen Partnern zu warten (receive), Antworten auf eine Anfrage zu verschicken
(reply), eine bestimmte Zeit zu warten (wait), den Variablen Werte zuzuweisen
(assign), Fehler zu generieren (throw), den gesamten Service explizit zu beenden (terminate)
oder auch nichts zu tun (empty). Die strukturierten Aktivitäten ermöglichen es die
primitiven zu einer komplexeren Einheit zu kombinieren. Es ist möglich, folgendes mit strukturierten
Aktivitäten zu realisieren: Eine geordnete Sequenz der Aktivitäten zu definieren
(sequence), Verzweigungen innerhalb eines Prozesses zu bilden (switch), Schleifen zu
definieren (while), Entscheidungen nach Ablauf bestimmter Zeit oder anhand externer
Trigger zu treffen (pick) und Aktivitäten parallel auszuführen (flow). Außerdem können
mit Hilfe des control links Konstrukts Ausführabhängigkeiten zwischen parallelen Aktivitäten
definiert werden.



 Das Besondere daran: WS-BPEL bietet eine homogene Syntax für die Ablaufbeschreibung und den Datenzugriff auf XML-Dokumente. Und es enthält Elemente, die speziell auf die Ablaufproblematik langlaufender Geschäftsprozesse mit mehreren Partnern zugeschnitten sind. So können die Aktivitäten eines Geschäftsprozesses in Scopes, das heißt in kontextorientierten, transaktionalen Einheiten zusammengefasst werden. Für den Fehlerfall, bei dem bereits abgeschlossene Scopes zurückgesetzt werden müssen - man spricht von Kompensation - , enthält WS-BPEL mächtige syntaktische Konstrukte. Hier ist WS-BPEL anderen Programmiersprachen klar überlegen - in der Theorie.


Nun lässt sich das Konzept der XPath-Variablen nutzen

In WS-BPEL 2.0 wurde das Konzept der XPath-Variablen eingeführt. Eine XPath-Variable entsteht syntaktisch einfach dadurch, dass einer BPEL-Variablen ein \$-Zeichen vorangestellt wird. Das Ergebnis einer Suche kann damit direkt als Ausdruck weiterbenutzt werden. Variablenzuweisungen, die in WS-BPEL durch <assign>-Aktivitäten erfolgen, lassen sich nun ähnlich elegant formulieren wie Zuweisungen in objektorientierten Sprachen.

Für Prozesse, in denen Suchen und Kopieren zum Aufbau von Nachrichten nicht ausreichen, bietet die neue BPEL-Version standardmäßig einen integrierten Ausdruck für die XSLT-Transformation einer XPath-Variablen.




Grundlegende Konzepte von SOA
Hinter Serviceorientierte Architekturen (SOA) steckt die Absicht, Geschäftsprozesse zu automatisieren und auf Maschine-zu Maschine-Kommunikation zu verlagern. Komplexe Anwendungen werden hierfür in standardisierte Services aufgebrochen und verteilt zur Verfügung gestellt.

BPEL ist blockstrukturiert, d.h. bei der Definition von lokalen Umgebungen (Scopes) können Variable (Programmierung) eingeführt werden. Mit den Scopes können außerdem Fehlerbehandlung (Fault Handler), Kompensationsbehandlung (Compensation Handler) und Ereignisbehandlung (Event Handler) assoziiert werden.
 
Man unterscheidet zwischen einer synchronen und asynchronen invoke-Aktivität.
Bei der synchronen Variante wird der Inhalt der Eingabevariable (inputVariable) an den entfernten Web Service geschickt und das Ergebnis in der Ausgabevariable (outputVariable) gespeichert. Für einen asynchronen Aufruf wird keine Ausgabevariable deklariert und der Prozess kann sofort nach dem Aufruf weiter ablaufen.
Aufruf einer Operation eines Dienstes. Kann synchron
oder asynchron sein.  als Folge auf eine <receive>-Aktion. Ein <reply> bezieht sich immer auf einen bestimmten Partnerlink und eine bestimmte Variable.

     invoke  Synchroner (requestresponse) oder asynchroner Aufruf eines Web Service
     receivereply  Anbieten einer synchronen oder asynchronen Web Service Schnittstelle







