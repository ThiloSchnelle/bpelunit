\subsection{Anforderungen}

Die Semantik darf nicht geändert werden. Die Metriken sollen einzeln gemessen werden.


Die primäre Aufgabe der Code-Coverage-Analyse liegt darin, die im Code durch Tests abgedeckten Bereiche  zu identifizieren und einige Kennzahlen der Abdeckungen zu ermitteln
(z.B. Anzahl der Durchläufe einer Codezeile). Daher werden bei der Code-Coverage-Analyse während der Testausführung
verschiedene Messungen durchgeführt, die jeweils Informationen über eine bestimmte Art der Abdeckung sammeln. Im
Folgenden werden die wichtigsten Messmetriken bei der Code-Coverage-Analyse aufgelistet.
wieviel des zu untersuchenden Codes tatsächlichdurch die Tests ausgeführt wurde. Es wird auch oft der Begriff \textit{Testabdeckung} verwendet.



\subsubsection{Normaler Kontrollfluss}
Den Kontrollfluss bestimmen in BPEL, wie bereits mehrmals erwähnt, die strukturierten Aktivitäten. In den folgenden Bildern sind die entsprechenden Kontrollflussgraphen abgebildet. Die grauen Elementen deuten an, wie die einzelnen Graphen in den Gesamtfluss eingebunden werden. Für die Zweigabdeckung relevanten Kanten sind schwarz dargestellt.
\begin{figure}[htbp!]
	\centering
		\includegraphics[width=0.65\textwidth]{bilder/h1.png}
	\label{fig:h1}
\end{figure}
\begin{figure}[htbp!]
	\centering
		\includegraphics[width=0.65\textwidth]{bilder/h2.png}
	\label{fig:h2}
\end{figure}

Bei den Aktivitäten, deren Graphen in der Abbildung vorhanden sind, entspricht der Kontrollfluss den Konstrukten, die aus vielen Programmiersprachen bekannt sind. Die Restlichen sind BPEL-spezifisch und müssen gesondert betrachtet werden.


\parpic(6.5cm,5cm)[r]{\includegraphics[width=0.30\textwidth]{bilder/pick.png}} 
\textbf{\textit{Pick}-Aktivität.}\\
Bei dieser strukturierenden Aktivität wird ein Zweig aus mehreren anhand eines Ereignisses (Nachricht oder Alarm) ausgewählt. Wurde ein zutreffendes Ereignis empfangen, so wird die zugehörige Aktivität ausgeführt und alle nachfolgenden Ereignisse verworfen. Aus der Sicht des Kontrollflusses stimmt dieses Verhalten mit dem einer IF-\-Akti\-vi\-tät überein. Deswegen werden diese beiden Aktivitäten im Kontrollfluss durch gleiche Graphen repräsentiert.

\textbf{\textit{Flow}-Aktivität.}\\
  Mit der \textit{Flow}-Aktivität wird in BPEL paralleler Ablauf mehrerer Aktivitäten realisiert. Außerdem gibt es mit dem Link-Konzept, ein mächtiges Instrument, das ermöglicht, Syn\-chro\-ni\-sa\-tions\-ab\-hän\-gig\-keiten aufzustellen und damit komplexe Abläufe zu realisieren. Die rechte Abbildung zeigt den zugehörigen Kontrollfluss. 
  \parpic(6.4cm,3.6cm)[r]{\includegraphics[width=0.33\textwidth]{bilder/flow.png}}
  Die Links (gestrichelte Pfeile) unterscheiden sich semantisch von den normalen Kanten des Kontrollflussgraphes.
  Wie es bereits im Abschnitt .. geschildert wurde, haben die Links trotzdem einen erheblichen Einfluss auf den Kontrollfluss und sind damit für die Zweigabdeckung relevant. 

  Aus der Sicht der Abdeckungsmessung ist die Tatsache besonders, dass der Status der Links drei Werte annehmen kann: \textit{true}, \textit{false} und \textit{unset}  Die normalen Kontrollflusskanten können dagegen nur zwei Werte annehmen: entweder \textit{aktiviert} oder \textit{nicht aktiviert}(\textit{unset}). Für die Links bedeutet das, dass \textit{true}- und \textit{false}-Status bei der Messung der Abdeckung erfasst werden müssen. 

\textbf{\textit{ForEach}-Aktivität.}
Die \textit{ForEach}-Aktivität sorgt für mehrmaliges Ausführen des enthaltenen Scopes. Die Anzahl der Ausführungen wird durch Start- und Stopvariablen vorgegeben. Die Besonderheit dabei ist, dass die Ausführung entweder sequenziell oder parallel erfolgen kann. Die Ausführungsart wird durch den  Wert der Variable \textit{parallel} (\textit{yes}/\textit{no}) geregelt. 

Dieses Verhalten kann durch zwei Graphen dargestellt werden. Die Abbildung ... repräsentiert sequentielle Ausführung, die einer for-Schleife aus den konventionellen Programmiersprachen entspricht. Der Graph daneben repräsentiert eine parallele Ausführung.
\begin{figure}[h!]
	\centering
		\includegraphics[width=0.73\textwidth]{bilder/forEeach2.png}
	\label{fig:forEeach2}
\end{figure}\\

Während der reguläre Kontrollfluss des Programms den Steuerfluss für alle reguläre Situationen vorgibt, gibt es in BPEL ein (\textit{FaultHandler})-Kontrollfluss, der für die Behandlung zur Laufzeit aufgetretener Fehler vorgesehen ist. Inwiefern dieses Verhalten in die Zweigabdeckung mit einfließen kann, wird im nächsten Abschnitt diskutiert. 
\subsubsection{Kontrollfluss bei Ausnahmebehandlung}
BPEL-Sprache hat wie viele moderne Programmiersprachen ein Konzept zur strukturierten Behandlung von Laufzeitfehlern. 
Die Umschaltung von normalen auf \textit{FaultHandler-}Kontrollfluss erfolgt automatisch beim Auftreten eines Fehlers. Was nichts anderes heißt, als dass der zugehörige \textit{FaultHandler} ausgeführt wird. Die Fehler können auch in den \textit{Compensation} und in den \textit{FaultHandler} selbst auftreten. In die Abbildung \ref{fig:ScopeFaultCompensation2} wird der Zusammenhang zwischen \textit{Handler} und \textit{Scopes} graphisch dargestellt und durch die Pfeile den möglichen Kontrollfluss zwischen diesen Einheiten gezeigt. 
\begin{figure}[h!]
	\centering
		\includegraphics[width=0.35\textwidth]{bilder/ScopeFaultCompensation2.png}
	\caption{Zusammenhang zwischen Scopes, Fault und Compensation Handler}
	\label{fig:ScopeFaultCompensation2}
\end{figure}

Vor allem die vielfältige Fehlerquellen und die Möglichkeit die Fehler weiterzuleiten machen es schwierig alle möglichen Übergaben der Aus\-füh\-rungs\-kon\-tro\-lle an die FaultHandler zu berücksichtigen. Aus diesem Grund werden die Verbindungskanten zwischen den Scopes, Fault und Compensation Handler in dieser Arbeit bei der Zweigabdeckung nicht berücksichtigt. 

Das Gleiche gilt für CompemsationHandler, die nur im Rahmen der Fehlerbehandlung ausgeführt werden.

Dass die Fault- und Compensation Handler, sowie die interne Logik dieser Handler, trotzdem durch die Tests abgedeckt werden sollten, ist unumstritten. Demzufolge ist es sinnvoll den Kontrollfluss \textit{innerhalb} der Handler bei der Messung der Abdeckung zu berücksichtigen. In der Abbildung .. wird der Kontrollfluss des gesamten Prozesses angedeutet. Die rote Farbe markiert den aktuellen Durchlauf. Während alle durchgezogenen Kanten (auch in \textit{Fault}- und \textit{CompensationHandler}) für die Zweigabdeckung relevant sind, gehen die gestrichelten, wie bereits erläutert, nicht in die Rechnung ein.  
\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.9\textwidth]{bilder/Fault_Compensation.png}
	\label{fig:Fault_Compensation}
\end{figure}
 
 In den folgenden Abschnitten werden die Metriken vorgestellt, die den Grad der durch die Tests abgedeckten Fault- bzw. Compensation Handler wiedergeben.
\\



Anweisungs¨uberdeckung wird im allgemeinen nicht als hinreichendes Kriterium
f¨ur die Vollst¨andigkeit eines Tests betrachtet, ihre Auswertung ergibt sich als
Nebenprodukt der Auswertung umfassenderer ¨Uberdeckungskriterien. Empirische
Untersuchungen zeigen eine Fehlererkennungsrate von 15\% bis unter 20\% f¨ur
reine Anweisungs¨uberdeckung. Sie liefert allerdings in allen Untersuchungen h¨ohere
Prozents¨atze als die statische Analyse des Quelltextes.
Die Kanten¨uberdeckung gilt als Standard bei kontrollflussbasierten ¨Uberdeckungsmaßen
und wird oft als Kriterium an Tests gestellt. Sie wird als leistungsf
¨ahiger Test vor allem zum Auffinden von logischen Fehlern betrachtet. Untersuchungen
bez¨uglich der Leistungsf¨ahigkeit streuen in einem weiten Bereich von
20\% bis 70\% gefundener Fehler. Zumeist liegen die Prozents¨atze im unteren Drittel
dieses Intervalls. Studien, die ebenfalls Anweisungs¨uberdeckung betrachten, zeigen
f¨ur Zweig¨uberdeckung eine Fehlererkennungsrate, die um 50% bis 100% ¨uber der
der Anweisungs¨uberdeckung liegt.
Bedingungs¨uberdeckung findet vor allem bei Systemen mit komplexer Verarbeitungslogik
Verwendung, die in der Regel kompliziert aufgebaute Bedingungen
verwende.



D

Erfolgsquote:
..Anweisungsüberdeckungstest 18%
..Zeigüberdeckungstest 32%
..Bedingungsüberdeckungstest ?
..Pfadüberdeckungstest 65%


Beim Erstellen von Tracedaten unterscheidet man zwischen Methoden, die es erfordern
den bestehenden Source- bzw. Objektcode zu instrumentieren und Methoden,
die automatisch Traceausgaben erzeugen. Moderne Entwicklungsumgebungen bieten
meist Techniken an, um Traceausgaben ohne Sourcecode-¨Anderung zu erstellen.


Die Testabdeckungsanalyse gibt an, in welchem Umfang die durchgeführten Tests die zu testende Software erfasst haben.



Bis jetzt wurde Instrumentierungsansatz allgemein betrachtet, ohne auf eine bestimmte Sprache einzugehen. Jetzt werden BPEL-spezifische Einschränkungen untersucht. Als Erstes dürfen nur BPEL-Aktivitäten eingefügt werden, sonst kann der BPEL-Prozess von der BPEL-Engine nicht ausgeführt werden. Um Protokollierung zu realisieren, muss eine Kommunikation von der Ausführungsumgebung nach außen stattfinden. Die einzige dafür geeignete Aktivität ist \textit{invoke}. Außerdem muss ein (lokales) Web Service eingerichtet werden, der für das Protokollieren zuständig ist. Bevor zu tief in die Details eingestiegen wird, werden zuerst die anderen Lösungsmöglichkeiten vorgestellt und besprochen.	
	
	
	\begin{itemize}
\item BPEL-Prozesse werden in speziellen Ablaufumgebungen (\textit{BPEL-Engine}) ausgeführt.
\item BPEL-Prozesse können nur mit Web Services (\textit{partner}) kommunizieren.
\begin{itemize}
	\item Die entsprechenden WSDL-Beschreibungen sind notwendig.
	\item Die \textit{partner link types} und \textit{partner liks} müssen definiert werden
\end{itemize}
	\item Businesslogik wird in BPEL-Prozesse durch BPEL-Aktivitäten (s. Abschnitt \ref{}) realisiert. 
\end{itemize}

\begin{figure}
	\centering
		\includegraphics[width=0.90\textwidth]{bilder/loggingservice.pdf}
	\label{fig:loggingservice}
\end{figure}



\newpage
\begin{figure}[h!]
	\includegraphics{bilder/StrukturedAktvities/sequence.pdf}
	\label{fig:sequence}
\end{figure}
\begin{figure}[h!]
	\includegraphics{bilder/StrukturedAktvities/pick.pdf}
	\label{fig:pick}
\end{figure}
\begin{figure}[h!]
	\includegraphics{bilder/StrukturedAktvities/while.pdf}
	\label{fig:while}
\end{figure}
\begin{figure}[h!]
	\includegraphics{bilder/StrukturedAktvities/flow.pdf}
	\label{fig:flow}
\end{figure}


Protokolliert man eine Aktivität, die das Ziel eines oder mehreren Links ist, davor, so kann es sein, dass sie aufgrund der transition- bzw. joinCondition gar nicht ausgeführt wird.
      \lstinline|print "hello world"|
      
      
      \lstset{emph={joinCondition,target }, emphstyle=\color{blue}}
      \begin{lstlisting}[caption=Beispielcode]{Name}
<flow>
  <links>
    <link name="CtoD"/>
  </links>
  <receive name="C" ...>
    <source linkName="CtoD"/>
  </receive>
  <invoke ... joinCondition=...>
    <target linkName="CtoD"/>
  </invoke>
</flow>      \end{lstlisting}

\lstset{emph={[2]sequence}, emphstyle=[2]\color{red}}
      \begin{lstlisting}[caption=Beispielcode][firstnumber=1]{Name}
<flow>
  <links>
    <link name="CtoD"/>
  </links>
  <receive name="C" ...>
    <source linkName="CtoD"/>
  </receive>
  <sequence joinCondition=...>
    <target linkName="CtoD"/>
    <!--Logging-->
    <invoke .../>
    <!--Logging-->
  </sequence>
</flow>      \end{lstlisting}

Für die Messung heisst es, während es bei normalen Kanten ausreichend ist, die aktivierten Kanten zu erfassen, muss es bei den Links zusätzlich zwischen \textit{true}- und \textit{false}-Status unterschieden werden. 