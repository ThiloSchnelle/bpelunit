
In diesem Abschnitt werden einige interessante Aspekte des Designs und der Implementierung vorgestellt. Anschließend wird die Integration des Moduls für die Messung der Testabdeckung in das BPELUnit Framework präsentiert und die implementierten Clients beschrieben. 

 
 \section{Externe Schnittstelle der Erweiterung}
 \textit{"`CoverageMeasurmentTool"'}  ist die Schnittstelle des Moduls für die Messung der Testabdeckung:
 \begin{figure}[htbp]
 \center
		\includegraphics[width=0.85\textwidth]{bilder/CoverageMeasurmentTool.png}
		\caption{Annotation der Kontrollflusszweigen - Klassen und Schnittstellen}
	\label{}
\end{figure}

\begin{itemize}
\item Konfiguration:
\begin{itemize}
	\item \textbf{\textit{configureMetrics}} - legt Testabdeckungsmetriken fest, die erhoben werden sollen,
	\item \textbf{\textit{setPathToWSDL}} - setzt Pfad zur WSDL-Beschreibung des Web Services zum Empfangen von Marken,
	\item \textbf{\textit{setSOAPEncoder}} - setzt den SOAPEncoder für die Dekodierung der Nachrichten mit Marken,
	\item \textbf{\textit{getEncodingStyle}} - gibt \textit{encoding style} der Nachrichten. \textit{Encoding style} ist für die Bestimmung des richtigen Encoders notwendig.
\end{itemize}
\item Instrumentierung:
\begin{itemize}
	\item \textbf{prepareArchiveForCoverageMeasurment} - erzeugt eine Kopie des \textit{Deployment}-Archivs und führt die Instrumentierung der BPEL-Dateien entsprechend der konfigurierten Metriken durch. Fügt alle benötigten für die Messung der Testabdeckung Daten in den Archive ein. Als Argumenten werden der Pfad zum Archive und der \textit{Deployer} übergeben. \textit{Deployer} wird benötigt, um festzustellen, welche BPEL-Engine zum Einsatz kommt und den entsprechenden Archive-Handler (siehe nächsten Abschnitt) auszuwählen. Wenn keine Fehler während der Instrumentierung, wie zum Beispiel falsche oder fehlende Konfiguration, auftreten, gibt die Methode den Namen der instrumentierten Archivekopie zurück. Die Kopie wird im Verzeichnis der Originaldatei abgelegt und nach dem Test gelöscht. Die entsprechenden Schreibrechte müssen vorhanden sein.  
\end{itemize}
\item Durchführung der Messung:
\begin{itemize}
	\item \textbf{\textit{putMessage}} - empfängt Nachrichten mit Marken.
	\item \textbf{\textit{setCurrentTestCase}} - setzt den Testfall, der gerade ausgeführt wird. Dadurch ist es möglich, die Testabdeckung jedes Testfalls zu bestimmen. 
	\item \textbf{\textit{setErrorStatus}} - 
	\item \textbf{\textit{setFailureStatus}} - 
\end{itemize}
\item Ergebnis:
\begin{itemize}
	\item \textbf{\textit{getStatistics}} - erzeugt Statistiken mit ermittelten Testabdeckungsmetriken.
\end{itemize}
\end{itemize}

\section{\textit{Archive-Handler}}
Für das \textit{Deployen} eines BPEL-Prozesses werden außer der BPEL-Datei selbst weitere Daten benötigt: WSDL Beschreibungen, Datentypen (XML Schema) und \textit{Deployment Descriptor} mit zusätzlichen Informationen für BPEL-Engine. Diese Daten werden üblicherweise zu einem Archive zusammengefasst und an die BPEL-Engine zur Ausführung übergeben.

Für die Messung der Testabdeckung mit dem Instrumentierungsansatz müssen BPEL-Dateien vor der Ausführung modifiziert werden. Das heißt, die entsprechenden Dateien müssen aus dem erstellten Kopiearchive  erst extrahiert und anschließend (nach der Instrumentierung) wieder in den Archive geschrieben werden. Außerdem muss Archive weitere Informationen für Engine bereithalten: die Beschreibung der Schnittstelle des Web Services zum Empfangen von Marken (\textit{Coverage Logging Service}) und wo dieser Service erreicht werden kann.
\begin{itemize}
	\item WSDL-Beschreibung des \textit{Coverage Logging}-Services,
	\item Endpoint des Partner Links zum \textit{Coverage Logging}-Service.
\end{itemize}

Sowohl die Struktur der Archive-Dateien als auch Syntax der \textit{Deployment Descriptoren} sind nicht durch BPEL spezifiziert und sind von Engine zu Engine unterschiedlich.
Das Modul für die Messung der Testabdeckung kann, wie das BPELUnit-Framework, verschiedene BPEL-Engines unterstützen. Für die zu unterstützende Engine ist folgende Schnittstelle zu implementieren. 
 \begin{figure}[htbp]
		\includegraphics[width=0.38\textwidth]{bilder/IDeploymentArchiveHandler.png}
\end{figure}

Die einzelne Methoden haben folgende Aufgaben:
\begin{itemize}
	\item \textbf{\textit{createArchiveCopy}} - erzeugt eine Kopie des Archivs, auf der die Instrumentierung durchgeführt wird.
	\item \textbf{\textit{addWSDLFile}} - kann in den Arvhive eine WSDL-Beschreibung hinzufügen (für \textit{Coverage Logging Service}).
	\item \textbf{\textit{addPartnerLinkEndpoint}} - fügt für den Partner Link (zum \textit{Coverage Logging Service}), WSDL service und port sowie die konkrete Adresse in \textit{Deployment Descriptor} ein.
	\item \textbf{\textit{getAllBPELFilenames}}, \textbf{\textit{getDocument}} und \textbf{\textit{writeDocument}} - ermöglichen die einzelnen Prozessebeschreibungen (BPEL-Dateien) in Form von XML-Dokumenten aus dem Archive zu extrahieren und wieder in den Archive zu schreiben. Diese Funktionalität wird für die Instrumentierung benötigt.
	\item \textbf{\textit{closeArchive}} - gibt Ressourcen frei.
\end{itemize}

Die Schnittstelle wurde innerhalb dieser Arbeit für \textit{ActiveBPEL Engine} implementiert. Am Beispiel dieser Engine werden einige Aspekte der Implementierung etwas genauer vorgestellt.

\textbf{ActiveBPEL Engine}.
Die Prozessbeschreibung sowie zugehörige Daten werden für diese Engine in ein jar-Archive mit Endung \textit{bpr} zusammengepackt. Für die Implementierung der Schnittstelle braucht man den Zugriff auf die Dateien im Archive. Zu diesem Zweck wird die Bibliothek \textit{"`TrueZip"'} verwendet, die einen transparenten Zugriff auf die Verzeichnisse und Dateien des Archivs ermöglicht. Mit dem Einfügen der WSDL-Datei in den Archive  (Methode \textbf{\textit{addWSDLFile}}) muss die Datei gleichzeitig in den \textit{WSDL-Katalog} (wsdlCatalog.xml) eingetragen werden.

Unter welcher Adresse (URL) der \textit{Coverage Logging Service} zu erreichen ist, wird im \textit{Deployment Descriptor} innerhalb der Methode \textit{addPartnerLinkEndpoint()} spezifiziert. 
 
\section{Instrumentierung}
Für alle Metriken wird die Schnittstelle \textit{IMetric} definiert:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 
\begin{wrapfigure}[13]{l}{5.5cm}
\centering%
\includegraphics[width=0.4\textwidth]{bilder/IMetric.png}%
\label{}
\end{wrapfigure} 
\begin{itemize}
\item \textbf{\textit{getName}} -
	\item \textbf{\textit{setOriginalBPELProzess}} - erhält noch nicht modifizierte Beschreibung des BPEL-Prozesses als XML-Element. Alle für die Instrumentierung benötigten Elemente der Prozessbeschreibung werden gespeichert,
	\item \textbf{\textit{getMarkersIds}} - gibt Präfixe von allen Marken dieser Metrik zurück. Sie ermöglichen die Zuordnung der empfangenen Marken einer Metrik,
	\item \textbf{\textit{insertMarkers}} - delegiert die Instrumentierungsaufgabe an eigenen Handler (siehe Abbildung \ref{fig:KlassendiagrammHandler},
 	\item \textbf{\textit{createStatistic}} - erzeugt Statistiken.
\end{itemize}
Für jede Metrik existiert eine Klasse, die diese Schnittstelle implementiert. Außerdem existiert für jede Metrik einen Handler, der die Annotation des Prozesses für diese Metrik übernimmt. Es werden im Folgenden beispielhaft die Klassen vorgestellt, die für die Zweigabdeckung zuständig sind (Abbildung \ref{fig:KlassendiagrammHandler})
 \begin{figure}[htbp]
 \center
		\includegraphics[width=0.83\textwidth]{bilder/Klassendiagramm1.png}
		\caption{Zusammenhang der Schnittstellen \textit{IMetric} und \textit{IMetricHandler}}
	\label{fig:KlassendiagrammHandler}
\end{figure}

Die Zweigabdeckung hängt in BPEL eng mit Strukturierten Aktivitäten zusammen. Im Abschnitt \ref{} wurde gezeigt, wie die Abdeckungsmessung in den einzelnen Aktivitäten umgesetzt werden kann. Die Schnittstelle \textit{IStructuredActivityHandler} verteilt die Instrumentierungsaufgabe auf mehreren Klassen.  Für jede Strukturierte Aktivität wird eine Klasse vorgesehen, die diese Schnittstelle implementiert, und die Zweige der jeweiligen Aktivität annotiert. So braucht der Handler der Zweigabdeckungsmetrik für die im Prozess auftretenden Strukturierten Aktivitäten lediglich die entsprechenden Handler aufzurufen. Auf diese Weise wird die Annotation des ganzen BPEL-Prozesses auf die Annotation der einzelnen Strukturierten Aktivitäten reduziert. Das Klassendiagramm \ref{fig:KlassendiagrammBrachmetric} stellt diese Beziehung grafisch dar.

 \begin{figure}[htbp]
 \center
		\includegraphics[width=\textwidth]{bilder/Klassendiagramm3.png}
		\caption{Annotation der Kontrollflusszweigen - Klassen und Schnittstellen}
	\label{fig:KlassendiagrammBrachmetric}
\end{figure}

Der zweite wesentliche Vorteil eines solchen Designs ist die einfache Möglichkeit, weitere Strukturierte Aktivitäten zu berücksichtigen. Einerseits könnte sich das als vorteilhaft bei den nächsten BPEL-Versionen erweisen, andererseits kann die Erweiterung einfacher für BPEL 1.1 angepasst werden.    

\section{Ergebnisse}
Die ermittelte Testabdeckung wird mit Hilfe der Schnittstellen \textit{IFileStatistic}, \textit{IStatistic} und der Klasse \textit{MarkerStatus} repräsentiert.

\begin{itemize}
	\item \textbf{\textit{IFileStatistic}} repräsentiert alle Testabdeckungs-Statistiken einer BPEL-Datei. 
	
\begin{itemize}
	\item \textbf{\textit{getBPELFileName}} -
	\item \textbf{\textit{setStatistics}} -
	\item \textbf{\textit{setStatistic}} -
\end{itemize}
	\item \textbf{\textit{IStatistic}}
\begin{itemize}
	\item \textbf{\textit{getName}} - liefert die Bezeichnung der Metrik,
	\item \textbf{\textit{getSubstatistics}} - liefert die Substatistiken, die eine Statistik haben kann. Es gibt entsprechende (\textit{add}-)Methode, die die Substatistiken hinzufügt,
	\item \textbf{\textit{setStateList}} - Parameter dieser Methode ist eine Liste von Marken, die jeweils mit einem Status (getestet oder nicht) behaftet sind,
	\item \textbf{\textit{getTotalNumber}} - Anzahl aller Elementen des BPEL-Prozesses, die für die zugehörige Metrik relevant sind,
	\item \textbf{\textit{getTestedNumber}} - diese Methoden liefern die Anzahl der getesteten Elementen des BPEL-Prozesses; es gibt noch eine Variante dieser Methode, die nur die Elementen berücksichtigt, die mit einem bestimmten Testfall getestet wurden,
\end{itemize}
	\item \textbf{\textit{MarkerStatus}} repräsentiert eine einzelne Marke, die mit einem Status (getestet oder nicht) behaftet ist. Es werden alle Testfälle gespeichert, bei denen die Merke vom \textit{Coverage Logging Service} empfangen wird.
\begin{itemize}
	\item \textbf{\textit{setStatus}}  -
	\item \textbf{\textit{isTested}} -
	\item \textbf{\textit{isTestedWithTestCase}} -	
	\item \textbf{\textit{getTestCases}} -
\end{itemize}
\end{itemize}

 \begin{figure}[htbp]
 \center
		\includegraphics[width=\textwidth]{bilder/KlassendiagrammResult.png}
		\caption{Klassen und Schnittstellen für die Ergebnisstatistiken}
	\label{fig:KlassendiagrammResult}
\end{figure}

Wichtig ist, dass eine Statistik entweder direkt die Marken verwaltet oder Substatistiken enthält und nicht beides gleichzeitig. Mit dieser Bedingung ist sichergestellt, dass Substatistiken eine disjunkte Zerlegung der (\textit{Gesamt}-)Statistik darstellen. So setzt sich die Statistik der Aktivitätabdeckung aus Abdeckungsstatistiken aller Basisaktivitäten zusammen. 


\section{Integration der Testabdeckungsmetriken in BPELUnit-Framework}
 \begin{figure}[htbp]
	\centering
		\includegraphics[width=0.9\textwidth]{bilder/bpelunit-architecture-with-coverage.pdf}
		\caption{BPELUnit-Architektur mit Erweiterung für die Messung der Testabdeckung }
	\label{fig:BPELUnitErweiterung}
\end{figure}

BPELUnit-Framework wird erweitert durch hinzufügen einer Phase vor dem tatsächlichen Testen. In dieser Phase wird der BPEL-Prozess annotiert , invoke-Aktivitäten werden hinzugefügt. Diese Aktivitäte sind Markierungen für jede Basisaktivität und jede Kontrollflussmöglichkeit. 

Zur Laufzeit rufen die Aktivitäten ein Web Service des BPELUnit-Frameworks . Bei diesen Aufrufen werden die Marken transportiert, die den Ausführungspfad zum BPELUnit Framework bzw. dem Modul für die Messung der Testabdeckung signalisieren. Nach der Ausführung können die Abdeckungsmetriken  anhand der empfangenen Marken und  statistischen Informationen über BPEL-Prozess  berechnet werden. 

BPELUnit-Framework wurde mit einem neuen Modul erweitert, der alle Aufgaben, die mit der Messung der Abdeckung zu tun haben, verwaltet (Abbildung \ref{fig:BPELUnitErweiterung}). So enthält dieser Modul einen Instrumentierer der die BPEL-Datei analysiert und Annotationen hinzufügt. Die Originaldatei wird durch annotierte Kopie ersetzt.  Zusätzlich ist ein Web Service für das Empfangen von Marken in diesem Modul enthalten. 

Das Framework ersetzt die Kommunikationspartner des BPEL-Prozesses durch Mock's, die die Geschäftsprozesse des Partners simulieren. Auf dieselbe Weise kann das Empfangen von Marken realisiert werden. Der Coverage Logging Service wird durch Testumgebung zur Verfügung gestellt (Abbildung \ref{fig:loggingservice}). 
 \begin{figure}[htbp]
	\centering
		\includegraphics[width=0.9\textwidth]{bilder/bpelProzess2.png}
		\caption{BPELUnit-Testumgebung}
	\label{fig:loggingservice}
\end{figure}

So kann die Funktionalität, die das Framework für die Kommunikation des Prozesses mit Mock's zur Verfügung stellt, auch für die Übetragung der Marken verwendet werden.  
BPELUnit-Framework übernimmt für die Ermittlung der Testabdeckung folgende Aufgaben:
\begin{itemize}
	\item das Deployen bzw. Simulieren von \textit{Coverage Logging Service},
	\item Dekodierung der SOAP-Nachtichten und Transport an den \textit{Coverage Logging Service}.
\end{itemize}

\subsection{Web Service zum Empfangen von Marken (Coverage Logging Service)}
Das BPELUnit-Framework simuliert die Partner des Prozesses auf einem lokalen Http-Server, der im Framework integriert ist.  Bei der Ausführung einer Testsuite wird der Webserver gestartet und ein Handler eingerichtet, der die Kommunikation zwischen dem Prozess und seinen Partnern regelt.  Es wird Open-Source-WebServer \textit{Jetty} verwendet.  

Der Port, auf dem die Partner simuliert werden, wird von dem Testenwickler in den Testsuites festgelegt. Der \textit{Coverage Logging Service} wartet auf Nachrichten auf einem anderen Port, der für ihn reserviert ist. Der Empfang und Auswertung der Marken wird von einem speziellen Handler unabhängig von allen anderen Nachrichten ausgeführt.

Um die Abdeckung der einzelnen Testfällen bestimmen zu können, muss bekannt sein, beim welchen Testfall die jeweilige Marke verschickt wurde. Es ist nicht möglich, aus dem ausgeführten BPEL-Prozess zu erfahren, welcher Testfall gerade ausgeführt wird. Die einzige Lösung ist, beim Start eines Testfalls eine Meldung an den \textit{Coverage Logging Service} zu schicken (kein Web Service-Aufruf). Dafür ist der Schnittstelle \textit{CoverageMeasurmentTool} die Methode \textit{setCurrentTestCase} vorgesehen. Das heißt, die Klasse \textit{TestcaseRunner}, die im BPELUnit Framework für den Start der Testfälle zuständig ist, ruft diese Methode auf und übergibt die Bezeichnung des Testfalls. 

Dabei gibt es ein Problem: es kann vorkommen, zum Beispiel bei vielen Nachrichten mit Marken, dass während die Nachrichten eines Testfalls noch übertragen werden, bereits alle Geschäftsinteraktionen des Testfalls abgearbeitet wurden und ein neuer Testfall gestartet wird. In diesem Fall findet falsche Zuordnung der Marken an die Testfälle statt. Direkt nach dem Beenden des letzten Testfalls wird der Webserver, auf dem die Partner und \textit{Coverage Logging Service} simuliert werden, heruntergefahren, dabei gehen die Nachrichten, die noch unterwegs sind, verloren. Das könnte zur falschen Werten für die Testabdeckung führen. Das Problem wird behoben, indem vor dem Starten des nächsten Testfalls bzw. vor dem Herunterfahren des Webservers eine bestimmte Zeitspanne abgewartet wird, um alle Nachrichten zu empfangen. Dadurch wird zwar die Zeit, die ein Test in Anspruch nimmt vergrößert, dafür liefert die Testabdeckung korrekte Werte. Die \textit{default}-Wartezeit ist auf  500ms gesetzt kann aber in der Konfigurationsdatei oder bei Eclipse-Plugin über die Konfigurationsmenü angepasst werden.

\subsection{BPELUnit-Clients}
Die Kernfunktionalitäten des BPELUnit-Frameworks, das Starten und Stoppen der Tests und Verfolgung des Testverlaufs, sind von der Präsentationsschicht unabhängig implementiert und können von beliebigen Clients verwendet werden. Das Framework enthält bereits drei Clients: Befehlszeilen-Client und Eclipse-Plugin und Ant-Integration. Die Befehlszeilen- und Eclipse-Plugin wurden innerhalb dieser Arbeit für neue Funktionalitäten der Testabdeckung erweitert.
\subsubsection{Befehlszeilen-Client}
Die Umgebungsvariable \textit{BPELUNIT\_HOME} muss auf Wurzelverzeichnis der BPELUnit installation zeigen.
Mit Hilfe eines neuen Parameters (\textit{-c}) kann eine Ausgabedatei für die Ergebnisse der Testabdeckung festgelegt werden.
Insgesamt stehen beim Aufruf folgende Optionen zur Verfügung:
\begin{verbatim}
bpelunit [-v] [-x=filename] [-l=filename] [-c=filename] testsuite.bpts
\end{verbatim}

\begin{itemize}
	\item \textit{-v} - detaillierte Ausgabe,
	\item \textit{-x} - lenkt die SXML-Ausgabe in die angegebene Datei um,
	\item \textit{-l} - lenkt die Log-Informationen in die angegebene Datei um,
	\item \textit{-c} - aktiviert die Messung er Testabdeckung und schreibt die Ergebnisse im XML-Format in die angegebene Datei.
\end{itemize}

Außerdem muss eine Konfigurationsdatei "`coverageMetricsConfiguration.xml"' im Verzeichnis \textit{BPELUNIT\_HOME/conf} vorhanden sein, die die zu ermittelnde Testabdeckungsmetriken festlegt:

\begin{verbatim}
<coverageMetrics 
  xmlns="http://www.bpelunit.org/schema/coverageMetricsConfiguration" waitingTime='500'>
     <metric name="ActivityCoverage">
            <property name="IncludeBasicActivities">
               invoke,receive,reply,throw,rethrow,wait,assign,
               empty,compensate,compensateScope,exit,terminate
            </property>
     </metric>
	   <metric name="BranchCoverage"/>
	   <metric name="LinkCoverage"/>
	   <metric name="FaultHandlerCoverage"/>
	   <metric name="CompensationHandlerCoverage"/>
</coverageMetrics>
\end{verbatim}
Soll eine Metrik nicht berechnet werden, so kann sie einfach auskommentiert werden. Für die Aktivitätabdeckung können zusätzlich die Basisaktivitäten festgelegt werden, die berücksichtigt werden sollen.

\subsubsection{Eclipse-Plugin}
Die Konfiguration der Metriken erfolgt im Eclipse-Plugin über Konfigurationspanel "`Testcoverage"'. Die Panel ist über \textit{preference}-Dialog der Eclipse erreichbar und ist in der nächsten Abbildung dargestellt.
\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.5\textwidth]{bilder/PreferenceMenu.png}
		\caption{}
	\label{}
\end{figure}

Nach der Ausführung der Testsuite wird eine Panel (\textit{view}) mit der ermittelten Testabdeckung angezeigt (Abbildung \ref{fig:testcoverageResult}). Links sind alle BPEL-Dateien des getesteten Archivs in einer Liste aufgezählt. Die Tabelle, die rechts von der Liste ist, zeigt die erreichte Testabdeckung für die ausgewählte Datei. Für jede Metrik werden dabei gesamte Anzahl der Elementen, Anzahl der beim Test abgedeckten Elementen und die erreichte Abdeckung in Prozent angezeigt. Mehrfachauswahl der Dateien ist auch möglich, so dass zum Beispiel die Abdeckung für den ganzen Deploymentarchiv angezeigt werden kann. 

Auf der rechten Seite sind alle Testfälle der Suite aufgelistet. Der Tester kann festlegen, welche Testfälle in der Statistik berücksichtigt werden. Auf diese Weise kann die Testabdeckung der einzelnen Testfälle ermittelt werden.

\begin{figure}[htbp]
	\centering
		\includegraphics[width=\textwidth]{bilder/CoverageResultMenu.png}
		\caption{}
	\label{fig:testcoverageResult}
\end{figure}




 
