Durch die Berechnung der Testabdeckung will der Tester erfahren, wie viel von dem Prüfling beim Testen ausgeführt wurde. Für die Definition des Prüflings, in diesem Fall BPEL-Prozesses, wird die BPEL Formalisierung von Ouyang in \cite{Chun2005} verwendet. Nach der Präsentation der wichtigsten Punkten dieser Formalisierung folgen die Definition der  Aktivität- und Zweigabdeckung. Darüber hinaus werden zwei speziell für BPEL definierten Metriken vorgestellt: Link- und Handler-Abdeckung.  
\section{Formale Definition von BPEL}\label{sec:bpelformal}
Die hier vorgestellte formale Beschreibung von WS-BPEL-Process Model ist nicht
vollständig und fasst nicht den gesamten Umfang von BPEL um. Es werden nur
für diese Arbeit relevante Teile des Modells beschrieben. Als Grundlage dient
eine Definition aus  \cite{Chun2005}, die abgesehen von der Anpassung an den
Standard WS-BPEL 2.0 und einigen Erweiterungen, unverändert übernommen wurde.  

Als Erstes wir eine Auswertungsfunktion definiert. Für die Definition einer entsprechenden Metrik wird eine Auswertungsfunktion
definiert). Sei $f$ eine boolsche Funktion (oder ein boolscher Ausdruck),
$Var(f)$ enthält aussagenlogische Variablen, die in $f$ vorkommen. Sei $F$ die Menge
der boolschen Funktionen und $B$ die Menge (\textit{true}, \textit{false}), dann ist die Variablenzuordnung von $F$ ist die Abbildung $assign: Var(F)\rightarrow B$, und eine Menge aller möglichen Variablenzuordnungen von $F$ ist $Assign(F)$. Die Auswertungsfunktion ist $eval: F \times Assign(F)\rightarrow B$.

\begin{Def}[WS-BPEL Process Model \cite{Chun2005}] Ein BPEL-Prozessmodell ist ein Tupel\\
$\mathcal{W=(A,\ E,\ C,\ L,\ HR,\ }type_{\mathcal{A}},\ type_{\mathcal{E}},\
instance,\ name,\ <_{seq},\ <_{if},\ serialscp,\ process,\\ trigger,\ scp_c,\
trigger_c,\ scp_t,\ trigger_{tf},\ \mathcal{LR},\ joincon,\ transitionCondition,\ supjoinf,\\ trigger_{jf})$ wobei: 
\end{Def}
\begin{itemize}\itemsep2pt
  \item $\mathcal{A}$ ist eine Menge von Aktivitäten,
  \item $\mathcal{E}$ ist eine Menge von Ereignissen,
  \item $\mathcal{C}$ ist eine Menge von Bedingungen,
  \item $\mathcal{L}$ ist eine Menge von Links (innerhalb von Flow-Aktivitäten),
  \item sei $\mathcal{B=E\cup C} \cup\{\bot\} $ eine Menge von Marken, wobei $\bot$ die leere Marke ist, dann ist $\mathcal{HR\subseteq A\times B\times A}$ ein annotierter Baum, der die Realaton zwischen einer Aktivität und ihren direkten Subaktivitäten definiert,
	\item $\forall a\in \mathcal{A},\ let\ \mathcal{HR}_{p}=_{\pi 1,3}\mathcal{HR}$ (Projektion auf zwei Aktivitätsmengen von $\mathcal{HR}$),\\
	$children(a)=\{a'\in \mathcal{A}|\mathcal{HR}_p(a,a')\}$ ist die Menge von unmittelbaren Nachfolgern von $a$,
	\item $type_\mathcal{A}:\mathcal{A\rightarrow T_A}$ ist Funktion, die den Aktivitäten die Aktivitätstypen zuordnet 
	
	\begin{itemize}\itemsep2pt
		\item $\mathcal{T_A=T_B\cup T_S}$
		\item $\mathcal{T_B}=\{receive,\ reply,\ wait,\ assign,\ validate,\ empty,\
		throw,\ rethrow,\\ \ compensate,\ compensateScope,\ exit\}$
 		\item $\mathcal{T_S}=\{sequence,\ flow,\ pick,\ if,\ while,\ repeatUntil,\
		forEach,\ scope\}$
    \end{itemize}
    
	\item $\forall t\in \mathcal{T_A},\ \mathcal{A}_t=\{a\in \mathcal{A}|type_\mathcal{A}(a)=t\}$ ist die Menge aller Aktivitäten des Types $t$,
 	\item $type_\mathcal{E}:\mathcal{E\rightarrow T_E}$ ist die Funktion, die den Ereignissen die Typen aus der Menge $\mathcal{T_E}$  zuordnet, wobei $\mathcal{T_E}=\{message,\ alarm,\ fault,\ compensation,\ termination\}.$
 	\item $\forall t\in \mathcal{T_E},\ \mathcal{E}_t=\{e\in \mathcal{E}|type_\mathcal{E}(e)=t\}$ ist die Menge der Ereignissen des Types $t$,
%\item $instance:\mathcal{A}_{receive}\cup \mathcal{A}_{pick}\rightarrow \mathcal{B}$ is a %function which sddigns a boolean value to the createInstance attribete of a receive or a %pick activity.
\item sei $\mathcal{A}^{structured}=\mathcal{A}_{sequence}\cup \mathcal{A}_{flow}\cup \mathcal{A}_{if}\cup \mathcal{A}_{while}\cup \mathcal{A}_{repeatUntil}\cup \mathcal{A}_{forEach}\cup \mathcal{A}_{pick}\cup \mathcal{A}_{scope}$ ist die Menge der Strukturierten Aktivitäten, $\forall_{s\in \mathcal{A}^{structured}}(children(s)\neq \emptyset)$, das heißt, sie sind die internen Knoten des $\mathcal{HR}$ Baumes,
\item sei $\mathcal{A}^{basic}=\mathcal{A}_{invoke}\cup \mathcal{A}_{receive}\cup \mathcal{A}_{reply}\cup \mathcal{A}_{wait}\cup \mathcal{A}_{assign}\cup \mathcal{A}_{validate}\cup \mathcal{A}_{empty}\cup \mathcal{A}_{validate}\cup \mathcal{A}_{throw}\cup \mathcal{A}_{rethrow}\cup \mathcal{A}_{compensate}\cup \mathcal{A}_{compensateScope}$ ist die Menge der Basisaktivitäten, $\forall_{s\in \mathcal{A}^{basic}}(children(s)= \emptyset)$, d.h., sie sind die Blätter des $\mathcal{HR}$ Baumes,
\item gegeben $\mathcal{A'}=\mathcal{A}_{sequence}\cup \mathcal{A}_{flow},\
\mathcal{HR} \cap (\mathcal{A}'\times B\times \mathcal{A})=\mathcal{HR} \cap
(\mathcal{A'}\times \{\bot\}\times \mathcal{A})$, diese $\mathcal{HR}$-Elemente repräsentieren automatische Kontrollübergabe von einer Aktivität an ihre Subaktivitäten. repräsentiert,
\item $\forall s\in \mathcal{A}_{sequence},\exists$ ist  $<^s_{seq}$ eine strenge totale Ordnung über $children(s)$,
\item $\mathcal{HR}\cap (\mathcal{A}_{pick}\times \mathcal{B}\times \mathcal{A})=\mathcal{HR}\cap (\mathcal{A}_{pick}\times \mathcal{E}^{normal}\times \mathcal{A})$, wobei $\mathcal{E}^{normal}=\mathcal{E}_{message}\cup \mathcal{E}_{alarm}$ eine Menge von normalen Ereignissen ist,
\item gegeben $\mathcal{A'}=\mathcal{A}_{if}\cup \mathcal{A}_{while}\cup
\mathcal{A}_{forEach},\ \mathcal{HR}\cap (\mathcal{A'}\times \mathcal{B}\times
\mathcal{A})=\mathcal{HR}\cap (\mathcal{A'}\times \mathcal{C}\times
\mathcal{A})$, so dass  \textit{if}-, \textit{while}- and \textit{forEach}-Aktivitäten bei der Übergabe der Kontrolle an ihre Subaktivitäten eine Bedingung auswerten müssen,
\item gegeben $\mathcal{A'}=\mathcal{A}_{repeatUntil},\ \mathcal{HR}\cap (\mathcal{A'}\times \mathcal{B}\times \mathcal{A})=\mathcal{HR}\cap (\mathcal{A'}\times \{\bot\}\times \mathcal{A}))$,
\item $\forall s\in \mathcal{A}_{if},\ \exists$ ist $<^{s}_{if}$ eine strenge totale Ordnung über $children(s)$,
\item $\forall s\in \mathcal{A}_{if}$, 
\begin{itemize}
	\item sei $last(s)\in children(s)$ die Subaktivität im letzten Zweig so, dass
	\item $\neg \exists_{a\in
children(s)}(last(s)<^{s}_{if}a)$, 
\item sei $c\in \mathcal{C}\mathcal{HR}(s,c,last(s))\Rightarrow \forall_{assign(c)\in
Assign(\mathcal{C})}eval(c,assign(c))=true$,
\end{itemize}
 $last(s)$ repräsentiert den \textit{else}-Zweig in \textit{if}-Aktivität, was  sichert zum einem, dass ein \textit{else}-Zweig immer vorhanden ist und zum anderen mindestens ein Zweig in der Aktivität aktiviert wird,
\item $\forall s\in \mathcal{A}_{while},\ \left| \mathcal{HR}\cap (\{s\}\times \mathcal{C}\times \mathcal{A})\right|=1$, d.h., hat exakt eine Subaktivität,
\item $\mathcal{HR}\cap (\mathcal{A}_{scope}\times \mathcal{B}\times \mathcal{A})=\mathcal{HR}\cap (\mathcal{A}_{scope} \times (\mathcal{E}\times\{\bot \})\times \mathcal{A})$, wobei: $\forall s \in \mathcal{A}_{scope}$,
\begin{itemize}\itemsep2pt
	\item $\left|\mathcal{HR}\cap (\{s\}\times \{\bot\}\times \mathcal{A})\right|=1$, d.h., jeder \textit{Scope} hat genau eine Aktivität,
	\item $\left|\mathcal{HR}\cap (\{s\}\times \{\mathcal{E}_{fault}\}\times \mathcal{A})\right|\geq 1$, d.h., jeder Scope hat mindestens einen \textit{Fault Handler},
		\item $\left|\mathcal{HR}\cap (\{s\}\times \{\mathcal{E}_{compensation}\}\times \mathcal{A})\right|\leq 1$, d.h., jeder Scope hat maximal einen \textit{Compensation Handler},
\end{itemize}
\item $process\in \mathcal{A}_{scope}$ ist der Wurzel des $\mathcal{HR}$ Baumes ,
\item $trigger_{tf}:\mathcal{A}_{throw}\cup \mathcal{A}_{rethrow}\rightarrow \mathcal{E}_{fault}$ ist die Funktion, die jede \textit{throw}-Aktivität auf ein Fehlerereignis abbildet, das durch diese Aktivität ausgelöst wird,
\item $scp_c:\mathcal{E}_{compensation}\rightarrow \mathcal{A}_{scope}\backslash \{process\}$ ist injektive Funktion, die das \textit{Compensation}-Ereignis auf ein Scope so abbildet, dass das Auftreten dieses Ereignisses die Kompensation dieses Scopes initiiert,
\item $trigger_c:\mathcal{A}_{compensate}\rightarrow \mathcal{E}_{compensation}$ ist injektive Funktion, die jede \textit{compensate}-Aktivität auf ein Compensation-Ereignis abbildet, das durch dises Aktivität ausgelöst wird,
\item $\mathcal{LR}\subseteq \mathcal{A}\times \mathcal{L}\times \mathcal{A}$ ist annotierter azyklischer Graph, der die Relation zwischen \textit{source}- und \textit{sarget}-Aktivität eines Links beschreibt,
\item sei $\mathcal{A}^{source}=\{a\in \mathcal{A}|\exists_{l\in \mathcal{L}}((a,l)\in\pi_{1,2}\mathcal{LR})\}$ die Menge von \textit{source}-Aktivitäten aller Links, und $\mathcal{A}^{target}=\{a\in \mathcal{A}|\exists_{l\in \mathcal{L}}((l,a)\in \pi_{2,3}\mathcal{LR})\}$  die Menge von \textit{target}-Aktivitäten aller Links, dann $\forall a\in \mathcal{A}^{source},\mathcal{L}_{out}(a)=
\{l\in \mathcal{L}|\exists_{a'\in \mathcal{A}}\mathcal{LR}(a,l,a')\}$ ist die Menge aller ausgehenden von $a$ Links, und $\forall a\in \mathcal{A}^{target}, \mathcal{L}_{in}(a)=\{l\in \mathcal{L}|\exists_{a'\in \mathcal{A}}\mathcal{LR}(a',l,a)\}$ ist die Menge aller eingehenden bei $a$ Links,
\item sei $a\in \mathcal{A}^{target},\ joincon(a)$, die die \textit{join condition} von $a$ definiert, ist boolsche Funktion über $\mathcal{L}_{in}(a)$(d.h. $Var(joincon(a))=\mathcal{L}_{in}(a))$,
\item sei $l\in_{ \pi 2}\mathcal{LR},\ transitionCondition(l)$,  die die \textit{transition condition} des Links $l$ definiert, ist boolsche Funktion,
\item Dead-path-elimination (DPE). 
Wird eine Aktivität aufgrund einer zu \textit{false} ausgewerteten \textit{join condition} oder eines nicht abgearbeiteten Zweiges einer $if-$ oder $pick-$Aktivität nicht ausgeführt, so wird für alle ausgehenden Links die \textit{transition condition} auf \textit{false }gesetzt. Dieses Verhalten wird als \textit{Dead-Path-Elimination} bezeichnet. 
\end{itemize}

Betrachtet man die Kontrollstruktur eines BPEL-Prozesses, so kann die $\mathcal{HR}$-Relation als Übergabe der Kontrolle von einer Aktivität an ihre Subaktivitäten interpretiert werden. Damit entspricht ein Element dieser Relation einem Zweig des Kontrollflussgraphen. Allerdings deckt diese Relation nicht alle Zweige des Graphen ab, es fehlen nämlich die Zweige, die die Kontrolle innerhalb der Schleifen von der inneren Aktivität an die Schleife zurückgeben. Die folgende Relation $\mathcal{HBR}$ beschreibt genau solche Beziehungen:
\begin{itemize}\itemsep2pt
	\item $\mathcal{HBR}\subseteq \mathcal{A}\times(\mathcal{C}\cup
	\{\bot\})\times \mathcal{A}$ beschreibt die Relation zwischen einer Aktivität und ihrer \textit{Parent}-Aktivität
	\item $\forall a,a'\in \mathcal{A},\ \forall(a,a')\in_{\pi
	1,3}\mathcal{HBR}\Rightarrow a\in children(a')$ 
\end{itemize}

Folglich gilt für die Schleifen:
\begin{itemize}\itemsep2pt
	\item gegeben $\mathcal{A'}=\mathcal{A}_{while}\cup \mathcal{A}_{forEach},\
	\mathcal{HBR}\cap (\mathcal{A}\times \mathcal{B}\times
	\mathcal{A'})=\mathcal{HBR}\cap (\mathcal{A}\times \{\bot \}\times 
	\mathcal{A'}),$   
	\item gegeben $\mathcal{A'}=\mathcal{A}_{repeatUntil},\ \mathcal{HBR}\cap
	(\mathcal{A}\times \mathcal{B}\times \mathcal{A'})=\mathcal{HBR}\cap
	(\mathcal{A}\times \mathcal{C}\times \mathcal{A'}).$
\end{itemize}


Die Relationen $\mathcal{HR}$ und $\mathcal{HBR}$ beschreiben zusammen alle Kanten des Kontrollflussgraphen des zugehörigen BPEL-Prozesses.
